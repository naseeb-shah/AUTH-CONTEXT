{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nodes = exports.list = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral\n} = _t;\n\nfunction crawl(node) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\n\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n\n  SwitchCase(node, parent) {\n    return {\n      before: !!node.consequent.length || parent.cases[0] === node,\n      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node\n    };\n  },\n\n  LogicalExpression(node) {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n\n  Literal(node) {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n\n  CallExpression(node) {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  OptionalCallExpression(node) {\n    if (isFunction(node.callee)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n\n  IfStatement(node) {\n    if (isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n\n};\nexports.nodes = nodes;\n\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nconst list = {\n  VariableDeclaration(node) {\n    return node.declarations.map(decl => decl.init);\n  },\n\n  ArrayExpression(node) {\n    return node.elements;\n  },\n\n  ObjectExpression(node) {\n    return node.properties;\n  }\n\n};\nexports.list = list;\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function (_ref) {\n  let [type, amounts] = _ref;\n\n  if (typeof amounts === \"boolean\") {\n    amounts = {\n      after: amounts,\n      before: amounts\n    };\n  }\n\n  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    nodes[type] = function () {\n      return amounts;\n    };\n  });\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","nodes","list","_t","require","FLIPPED_ALIAS_KEYS","isArrayExpression","isAssignmentExpression","isBinary","isBlockStatement","isCallExpression","isFunction","isIdentifier","isLiteral","isMemberExpression","isObjectExpression","isOptionalCallExpression","isOptionalMemberExpression","isStringLiteral","crawl","node","state","object","computed","property","left","right","hasCall","callee","hasFunction","hasHelper","isHelper","name","isType","AssignmentExpression","before","after","SwitchCase","parent","consequent","length","cases","LogicalExpression","Literal","CallExpression","OptionalCallExpression","VariableDeclaration","i","declarations","declar","enabled","id","init","IfStatement","ObjectProperty","ObjectTypeProperty","ObjectMethod","properties","ObjectTypeCallProperty","_parent$properties","callProperties","ObjectTypeIndexer","_parent$properties2","_parent$callPropertie","indexers","ObjectTypeInternalSlot","_parent$properties3","_parent$callPropertie2","_parent$indexers","internalSlots","map","decl","ArrayExpression","elements","ObjectExpression","forEach","type","amounts","concat"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/generator/lib/node/whitespace.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nodes = exports.list = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral\n} = _t;\n\nfunction crawl(node, state = {}) {\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\n\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n\n  SwitchCase(node, parent) {\n    return {\n      before: !!node.consequent.length || parent.cases[0] === node,\n      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node\n    };\n  },\n\n  LogicalExpression(node) {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n\n  Literal(node) {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n\n  CallExpression(node) {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  OptionalCallExpression(node) {\n    if (isFunction(node.callee)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n\n  IfStatement(node) {\n    if (isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n\n};\nexports.nodes = nodes;\n\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nconst list = {\n  VariableDeclaration(node) {\n    return node.declarations.map(decl => decl.init);\n  },\n\n  ArrayExpression(node) {\n    return node.elements;\n  },\n\n  ObjectExpression(node) {\n    return node.properties;\n  }\n\n};\nexports.list = list;\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function ([type, amounts]) {\n  if (typeof amounts === \"boolean\") {\n    amounts = {\n      after: amounts,\n      before: amounts\n    };\n  }\n\n  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    nodes[type] = function () {\n      return amounts;\n    };\n  });\n});"],"mappings":"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"},"metadata":{},"sourceType":"script"}