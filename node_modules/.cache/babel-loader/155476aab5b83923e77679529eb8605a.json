{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n});\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\n\nvar _t = require(\"@babel/types\");\n\nvar _modules = require(\"./modules\");\n\nvar _types2 = require(\"./types\");\n\nconst {\n  isDeclareExportDeclaration,\n  isStatement\n} = _t;\n\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\n\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\n\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\n\nfunction DeclareClass(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"class\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction DeclareFunction(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n\n  this.semicolon();\n}\n\nfunction InferredPredicate() {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nfunction DeclaredPredicate(node) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value, node);\n  this.token(\")\");\n}\n\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nfunction DeclareOpaqueType(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.OpaqueType(node);\n}\n\nfunction DeclareVariable(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.apply(this, arguments);\n}\n\nfunction DeclareExportAllDeclaration() {\n  this.word(\"declare\");\n  this.space();\n\n  _modules.ExportAllDeclaration.apply(this, arguments);\n}\n\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\n\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n\n  context.space();\n}\n\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n\n  context.dedent();\n  context.token(\"}\");\n}\n\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id, node);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(context, node) {\n  const {\n    id,\n    init\n  } = node;\n  context.print(id, node);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(init, node);\n  context.token(\",\");\n}\n\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ExistsTypeAnnotation() {\n  this.token(\"*\");\n}\n\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation, node);\n\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n\n  this.token(\")\");\n\n  if (parent && (parent.type === \"ObjectTypeCallProperty\" || parent.type === \"DeclareFunction\" || parent.type === \"ObjectTypeProperty\" && parent.method)) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.token(\"?\");\n\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n\n  this.print(node.typeAnnotation, node);\n}\n\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction _interfaceish(node) {\n  var _node$extends;\n\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if ((_node$extends = node.extends) != null && _node$extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n\n  if (node.implements && node.implements.length) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _variance(node) {\n  if (node.variance) {\n    if (node.variance.kind === \"plus\") {\n      this.token(\"+\");\n    } else if (node.variance.kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction andSeparator() {\n  this.space();\n  this.token(\"&\");\n  this.space();\n}\n\nfunction InterfaceTypeAnnotation(node) {\n  this.word(\"interface\");\n\n  if (node.extends && node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\n\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\n\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\n\nfunction NullableTypeAnnotation(node) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\n\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\n\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\n\nfunction TupleTypeAnnotation(node) {\n  this.token(\"[\");\n  this.printList(node.types, node);\n  this.token(\"]\");\n}\n\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\n\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\n\nfunction TypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TypeParameterInstantiation(node) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nfunction TypeParameter(node) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype, node);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];\n\n  if (props.length) {\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(\",\");\n          this.space();\n        }\n      }\n    });\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n\n    if (props.length) {\n      this.newline();\n    }\n\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id, node);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.token(\"[\");\n\n  if (node.id) {\n    this.print(node.id, node);\n    this.token(\":\");\n    this.space();\n  }\n\n  this.print(node.key, node);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.print(node.key, node);\n  if (node.optional) this.token(\"?\");\n\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.token(\".\");\n  this.print(node.id, node);\n}\n\nfunction SymbolTypeAnnotation() {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator() {\n  this.space();\n  this.token(\"|\");\n  this.space();\n}\n\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\n\nfunction TypeCastExpression(node) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction Variance(node) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}\n\nfunction IndexedAccessType(node) {\n  this.print(node.objectType, node);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nfunction OptionalIndexedAccessType(node) {\n  this.print(node.objectType, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","AnyTypeAnnotation","ArrayTypeAnnotation","BooleanLiteralTypeAnnotation","BooleanTypeAnnotation","DeclareClass","DeclareExportAllDeclaration","DeclareExportDeclaration","DeclareFunction","DeclareInterface","DeclareModule","DeclareModuleExports","DeclareOpaqueType","DeclareTypeAlias","DeclareVariable","DeclaredPredicate","EmptyTypeAnnotation","EnumBooleanBody","EnumBooleanMember","EnumDeclaration","EnumDefaultedMember","EnumNumberBody","EnumNumberMember","EnumStringBody","EnumStringMember","EnumSymbolBody","ExistsTypeAnnotation","FunctionTypeAnnotation","FunctionTypeParam","IndexedAccessType","InferredPredicate","InterfaceDeclaration","GenericTypeAnnotation","ClassImplements","InterfaceExtends","InterfaceTypeAnnotation","IntersectionTypeAnnotation","MixedTypeAnnotation","NullLiteralTypeAnnotation","NullableTypeAnnotation","enumerable","get","_types2","NumericLiteral","NumberTypeAnnotation","ObjectTypeAnnotation","ObjectTypeCallProperty","ObjectTypeIndexer","ObjectTypeInternalSlot","ObjectTypeProperty","ObjectTypeSpreadProperty","OpaqueType","OptionalIndexedAccessType","QualifiedTypeIdentifier","StringLiteral","StringTypeAnnotation","SymbolTypeAnnotation","ThisTypeAnnotation","TupleTypeAnnotation","TypeAlias","TypeAnnotation","TypeCastExpression","TypeParameter","TypeParameterDeclaration","TypeParameterInstantiation","TypeofTypeAnnotation","UnionTypeAnnotation","Variance","VoidTypeAnnotation","_interfaceish","_variance","_t","require","_modules","isDeclareExportDeclaration","isStatement","word","node","print","elementType","token","parent","space","id","typeAnnotation","predicate","semicolon","body","default","FlowExportDeclaration","apply","arguments","ExportAllDeclaration","enumExplicitType","context","name","hasExplicitType","enumBody","members","indent","newline","member","hasUnknownMembers","dedent","explicitType","enumInitializedMember","init","declaration","declar","specifiers","length","printList","source","typeParameters","this","params","rest","type","method","returnType","optional","_node$extends","extends","mixins","implements","variance","kind","andSeparator","printJoin","types","separator","argument","right","bound","supertype","impltype","exact","props","properties","callProperties","indexers","internalSlots","addNewlines","leading","statement","iterator","inexact","static","key","proto","qualification","orSeparator","expression","objectType","indexType"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/generator/lib/generators/flow.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n});\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\n\nvar _t = require(\"@babel/types\");\n\nvar _modules = require(\"./modules\");\n\nvar _types2 = require(\"./types\");\n\nconst {\n  isDeclareExportDeclaration,\n  isStatement\n} = _t;\n\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\n\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\n\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\n\nfunction DeclareClass(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"class\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction DeclareFunction(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n\n  this.semicolon();\n}\n\nfunction InferredPredicate() {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nfunction DeclaredPredicate(node) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value, node);\n  this.token(\")\");\n}\n\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nfunction DeclareOpaqueType(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.OpaqueType(node);\n}\n\nfunction DeclareVariable(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.apply(this, arguments);\n}\n\nfunction DeclareExportAllDeclaration() {\n  this.word(\"declare\");\n  this.space();\n\n  _modules.ExportAllDeclaration.apply(this, arguments);\n}\n\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\n\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n\n  context.space();\n}\n\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n\n  context.dedent();\n  context.token(\"}\");\n}\n\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id, node);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(context, node) {\n  const {\n    id,\n    init\n  } = node;\n  context.print(id, node);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(init, node);\n  context.token(\",\");\n}\n\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ExistsTypeAnnotation() {\n  this.token(\"*\");\n}\n\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation, node);\n\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n\n  this.token(\")\");\n\n  if (parent && (parent.type === \"ObjectTypeCallProperty\" || parent.type === \"DeclareFunction\" || parent.type === \"ObjectTypeProperty\" && parent.method)) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.token(\"?\");\n\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n\n  this.print(node.typeAnnotation, node);\n}\n\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction _interfaceish(node) {\n  var _node$extends;\n\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if ((_node$extends = node.extends) != null && _node$extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n\n  if (node.implements && node.implements.length) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _variance(node) {\n  if (node.variance) {\n    if (node.variance.kind === \"plus\") {\n      this.token(\"+\");\n    } else if (node.variance.kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction andSeparator() {\n  this.space();\n  this.token(\"&\");\n  this.space();\n}\n\nfunction InterfaceTypeAnnotation(node) {\n  this.word(\"interface\");\n\n  if (node.extends && node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\n\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\n\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\n\nfunction NullableTypeAnnotation(node) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\n\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\n\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\n\nfunction TupleTypeAnnotation(node) {\n  this.token(\"[\");\n  this.printList(node.types, node);\n  this.token(\"]\");\n}\n\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\n\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\n\nfunction TypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TypeParameterInstantiation(node) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nfunction TypeParameter(node) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype, node);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];\n\n  if (props.length) {\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(\",\");\n          this.space();\n        }\n      }\n    });\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n\n    if (props.length) {\n      this.newline();\n    }\n\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id, node);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.token(\"[\");\n\n  if (node.id) {\n    this.print(node.id, node);\n    this.token(\":\");\n    this.space();\n  }\n\n  this.print(node.key, node);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.print(node.key, node);\n  if (node.optional) this.token(\"?\");\n\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.token(\".\");\n  this.print(node.id, node);\n}\n\nfunction SymbolTypeAnnotation() {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator() {\n  this.space();\n  this.token(\"|\");\n  this.space();\n}\n\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\n\nfunction TypeCastExpression(node) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction Variance(node) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}\n\nfunction IndexedAccessType(node) {\n  this.print(node.objectType, node);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nfunction OptionalIndexedAccessType(node) {\n  this.print(node.objectType, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}