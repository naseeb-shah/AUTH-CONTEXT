{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_t","require","_t2","react","cloneNode","jsxExpressionContainer","variableDeclaration","variableDeclarator","referenceVisitor","ReferencedIdentifier","path","state","isJSXIdentifier","isCompatTag","node","name","parentPath","isJSXMemberExpression","scope","isFunction","isArrowFunctionExpression","parent","breakOnScopePaths","push","binding","getBinding","violation","constantViolations","mutableBinding","stop","bindings","PathHoister","constructor","scopes","attachAfter","isCompatibleScope","key","keys","bindingIdentifierEquals","identifier","getCompatibleScopes","indexOf","getAttachmentPath","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","bindingParentPath","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","bodies","get","i","length","_blockHoist","getNextScopeAttachmentParent","Array","isArray","container","isStatement","constant","run","traverse","attachTo","getFunctionParent","uid","generateUidIdentifier","declarator","insertFn","attached","isVariableDeclarator","isJSXElement","children","replaceWith"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/traverse/lib/path/lib/hoister.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;"],"mappings":"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"},"metadata":{},"sourceType":"script"}