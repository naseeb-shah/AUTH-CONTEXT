{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.get = get;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getNextSibling = getNextSibling;\nexports.getOpposite = getOpposite;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getPrevSibling = getPrevSibling;\nexports.getSibling = getSibling;\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  isDeclaration,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records.push(...breakCompletions);\n  }\n\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions.push(...statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths() {\n  let duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (isDeclaration(declaration)) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_getKey","_getPattern","get","getAllNextSiblings","getAllPrevSiblings","getBindingIdentifierPaths","getBindingIdentifiers","getCompletionRecords","getNextSibling","getOpposite","getOuterBindingIdentifierPaths","getOuterBindingIdentifiers","getPrevSibling","getSibling","_index","require","_t","_getBindingIdentifiers","_getOuterBindingIdentifiers","isDeclaration","numericLiteral","unaryExpression","NORMAL_COMPLETION","BREAK_COMPLETION","NormalCompletion","path","type","BreakCompletion","key","addCompletionRecords","records","context","push","_getCompletionRecords","completionRecordForSwitch","cases","lastNormalCompletions","i","length","casePath","caseCompletions","normalCompletions","breakCompletions","c","normalCompletionToBreak","completions","forEach","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","label","replaceWith","remove","getStatementListCompletion","paths","canHaveBreak","newContext","assign","inCaseClause","isBlockStatement","shouldPopulateBreak","statementCompletions","every","some","pathCompletions","isVariableDeclaration","isIfStatement","isDoExpression","isFor","isWhile","isLabeledStatement","isProgram","isFunction","isTryStatement","isCatchClause","isSwitchStatement","isSwitchCase","map","r","default","parentPath","parent","container","listKey","setContext","_key","sibling","siblings","node","parts","split","Array","isArray","_","part","duplicates","outerOnly","search","ids","create","id","shift","keys","isIdentifier","_ids","name","isExportDeclaration","declaration","isFunctionDeclaration","isFunctionExpression","child"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/traverse/lib/path/family.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.get = get;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getNextSibling = getNextSibling;\nexports.getOpposite = getOpposite;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getPrevSibling = getPrevSibling;\nexports.getSibling = getSibling;\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  isDeclaration,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records.push(...breakCompletions);\n  }\n\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions.push(...statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (isDeclaration(declaration)) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}