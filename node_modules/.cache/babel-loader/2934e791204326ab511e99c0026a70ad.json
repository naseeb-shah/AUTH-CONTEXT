{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClassDeclaration,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    arrowBody: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, {\n    expressionStatement: true\n  });\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction TSInstantiationExpression(node, parent) {\n  return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  var _node$extra;\n\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {\n    left: node\n  }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {\n    return true;\n  }\n\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, {\n      expressionStatement: isFollowedByBracket,\n      forHead: isFollowedByBracket,\n      forInHead: isFollowedByBracket,\n      forOfHead: true\n    });\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, _ref) {\n  let {\n    expressionStatement = false,\n    arrowBody = false,\n    exportDefault = false,\n    forHead = false,\n    forInHead = false,\n    forOfHead = false\n  } = _ref;\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ArrowFunctionExpression","AssignmentExpression","Binary","BinaryExpression","ClassExpression","ConditionalExpression","DoExpression","FunctionExpression","FunctionTypeAnnotation","Identifier","LogicalExpression","NullableTypeAnnotation","ObjectExpression","OptionalIndexedAccessType","OptionalCallExpression","OptionalMemberExpression","SequenceExpression","TSAsExpression","TSInferType","TSInstantiationExpression","TSTypeAssertion","TSIntersectionType","TSUnionType","UnaryLike","IntersectionTypeAnnotation","UnionTypeAnnotation","UpdateExpression","AwaitExpression","YieldExpression","_t","require","isArrayTypeAnnotation","isArrowFunctionExpression","isAssignmentExpression","isAwaitExpression","isBinary","isBinaryExpression","isUpdateExpression","isCallExpression","isClassDeclaration","isClassExpression","isConditional","isConditionalExpression","isExportDeclaration","isExportDefaultDeclaration","isExpressionStatement","isFor","isForInStatement","isForOfStatement","isForStatement","isFunctionExpression","isIfStatement","isIndexedAccessType","isIntersectionTypeAnnotation","isLogicalExpression","isMemberExpression","isNewExpression","isNullableTypeAnnotation","isObjectPattern","isOptionalCallExpression","isOptionalMemberExpression","isReturnStatement","isSequenceExpression","isSwitchStatement","isTSArrayType","isTSAsExpression","isTSInstantiationExpression","isTSIntersectionType","isTSNonNullExpression","isTSOptionalType","isTSRestType","isTSTypeAssertion","isTSUnionType","isTaggedTemplateExpression","isThrowStatement","isTypeAnnotation","isUnaryLike","isUnionTypeAnnotation","isVariableDeclarator","isWhileStatement","isYieldExpression","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","superClass","hasPostfixPart","object","callee","tag","printStack","length","isFirstInContext","expressionStatement","arrowBody","async","operator","left","parentOp","parentPos","nodeOp","nodePos","right","objectType","typeParameters","test","discriminant","expression","exportDefault","_node$extra","extra","parenthesized","id","name","isFollowedByBracket","computed","optional","forHead","forInHead","forOfHead","i","declaration","body","init","expressions","prefix"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/generator/lib/node/parentheses.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClassDeclaration,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    arrowBody: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, {\n    expressionStatement: true\n  });\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction TSInstantiationExpression(node, parent) {\n  return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  var _node$extra;\n\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {\n    left: node\n  }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {\n    return true;\n  }\n\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, {\n      expressionStatement: isFollowedByBracket,\n      forHead: isFollowedByBracket,\n      forInHead: isFollowedByBracket,\n      forOfHead: true\n    });\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, {\n  expressionStatement = false,\n  arrowBody = false,\n  exportDefault = false,\n  forHead = false,\n  forInHead = false,\n  forOfHead = false\n}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}