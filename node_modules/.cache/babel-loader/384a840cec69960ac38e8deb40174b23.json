{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nexports.wrapInterop = wrapInterop;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _rewriteThis = require(\"./rewrite-this\");\n\nvar _rewriteLiveReferences = require(\"./rewrite-live-references\");\n\nvar _normalizeAndLoadMetadata = require(\"./normalize-and-load-metadata\");\n\nvar _getModuleName = require(\"./get-module-name\");\n\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction rewriteModuleStatementsAndPrepareHeader(path, _ref) {\n  let {\n    loose,\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    lazy,\n    esNamespaceOnly,\n    filename,\n    constantReexports = loose,\n    enumerableModuleMeta = loose,\n    noIncompleteNsImportDetection\n  } = _ref;\n  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);\n\n  _assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly,\n    filename\n  });\n\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n\n  (0, _rewriteLiveReferences.default)(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", directive(directiveLiteral(\"use strict\")));\n    }\n  }\n\n  const headers = [];\n\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));\n  return {\n    meta,\n    headers\n  };\n}\n\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\n\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [expr, booleanLiteral(true)]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\nfunction buildNamespaceInitStatements(metadata, sourceMetadata) {\n  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const statements = [];\n  let srcNamespace = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: _template.default.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\n\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\n  const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, _ref2 => {\n    let [exportName, importName] = _ref2;\n    let NAMESPACE_IMPORT = cloneNode(namespace);\n\n    if (importName === \"default\" && metadata.interop === \"node-default\") {} else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));\n    }\n\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\nfunction buildESModuleHeader(metadata) {\n  let enumerableModuleMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\n\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\n\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [variableDeclarator(name, valueToNode(exportedVars))])\n  };\n}\n\nfunction buildExportInitializationStatements(programPath, metadata) {\n  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let noIncompleteNsImportDetection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const initStatements = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  initStatements.sort((_ref3, _ref4) => {\n    let [a] = _ref3;\n    let [b] = _ref4;\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n  const results = [];\n\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    const chunkSize = 100;\n\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n            uninitializedExportNames = [];\n          }\n\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n\n      if (uninitializedExportNames.length > 0) {\n        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n      }\n    }\n  }\n\n  return results;\n}\n\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\n\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","buildNamespaceInitStatements","ensureStatementsHoisted","enumerable","get","_getModuleName","default","_normalizeAndLoadMetadata","hasExports","_helperModuleImports","isModule","isSideEffectImport","rewriteModuleStatementsAndPrepareHeader","_rewriteThis","wrapInterop","_assert","require","_t","_template","_rewriteLiveReferences","booleanLiteral","callExpression","cloneNode","directive","directiveLiteral","expressionStatement","identifier","isIdentifier","memberExpression","stringLiteral","valueToNode","variableDeclaration","variableDeclarator","path","loose","exportName","strict","allowTopLevelThis","strictMode","noInterop","importInterop","lazy","esNamespaceOnly","filename","constantReexports","enumerableModuleMeta","noIncompleteNsImportDetection","validateImportInteropOption","node","sourceType","meta","initializeReexports","hasStrict","directives","some","unshiftContainer","headers","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","buildExportInitializationStatements","statements","forEach","header","_blockHoist","programPath","expr","type","hub","addHelper","helper","Error","metadata","sourceMetadata","srcNamespace","localName","importsNamespace","NAME","SOURCE","buildReexportsFromMeta","reexportNamespace","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","constantComputed","spec","namespace","stringSpecifiers","Array","from","reexports","importName","NAMESPACE_IMPORT","interop","has","astNodes","EXPORT_NAME","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","create","data","local","values","names","hasReexport","source","keys","length","scope","generateUidIdentifier","initStatements","kind","buildInitStatement","reexportsStatements","i","sort","a","b","results","initStatement","chunkSize","uninitializedExportNames","j","buildUndefinedNode","InitTemplate","computed","expression","exportNames","initExpr","reduce","acc","params","VALUE"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/helper-module-transforms/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nexports.wrapInterop = wrapInterop;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _rewriteThis = require(\"./rewrite-this\");\n\nvar _rewriteLiveReferences = require(\"./rewrite-live-references\");\n\nvar _normalizeAndLoadMetadata = require(\"./normalize-and-load-metadata\");\n\nvar _getModuleName = require(\"./get-module-name\");\n\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction rewriteModuleStatementsAndPrepareHeader(path, {\n  loose,\n  exportName,\n  strict,\n  allowTopLevelThis,\n  strictMode,\n  noInterop,\n  importInterop = noInterop ? \"none\" : \"babel\",\n  lazy,\n  esNamespaceOnly,\n  filename,\n  constantReexports = loose,\n  enumerableModuleMeta = loose,\n  noIncompleteNsImportDetection\n}) {\n  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);\n\n  _assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly,\n    filename\n  });\n\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n\n  (0, _rewriteLiveReferences.default)(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", directive(directiveLiteral(\"use strict\")));\n    }\n  }\n\n  const headers = [];\n\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));\n  return {\n    meta,\n    headers\n  };\n}\n\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\n\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [expr, booleanLiteral(true)]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\nfunction buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false) {\n  const statements = [];\n  let srcNamespace = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: _template.default.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\n\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\n  const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT = cloneNode(namespace);\n\n    if (importName === \"default\" && metadata.interop === \"node-default\") {} else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));\n    }\n\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\nfunction buildESModuleHeader(metadata, enumerableModuleMeta = false) {\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\n\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\n\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [variableDeclarator(name, valueToNode(exportedVars))])\n  };\n}\n\nfunction buildExportInitializationStatements(programPath, metadata, constantReexports = false, noIncompleteNsImportDetection = false) {\n  const initStatements = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  initStatements.sort(([a], [b]) => {\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n  const results = [];\n\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    const chunkSize = 100;\n\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n            uninitializedExportNames = [];\n          }\n\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n\n      if (uninitializedExportNames.length > 0) {\n        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n      }\n    }\n  }\n\n  return results;\n}\n\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\n\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}