{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar _t = require(\"@babel/types\");\n\nvar t = _t;\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst {\n  validate\n} = _t;\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get(_ref) {\n    let {\n      hub,\n      parentPath,\n      parent,\n      container,\n      listKey,\n      key\n    } = _ref;\n\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  hasNode() {\n    return this.node != null;\n  }\n\n  buildCodeFrameError(msg) {\n    let Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n{\n  NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;\n}\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","SHOULD_STOP","SHOULD_SKIP","REMOVED","virtualTypes","require","_debug","_index","_scope","_t","t","_cache","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","validate","debug","NodePath","constructor","hub","parent","contexts","state","opts","_traverseFlags","skipKeys","parentPath","container","listKey","key","node","type","data","context","scope","get","Error","targetNode","paths","path","Map","set","setup","getScope","isScope","setData","val","create","getData","def","undefined","hasNode","buildCodeFrameError","msg","SyntaxError","buildError","traverse","visitor","getPathLocation","parts","inList","unshift","join","message","enabled","toString","code","parentKey","shouldSkip","v","shouldStop","removed","assign","prototype","_guessExecutionStatusRelativeToDifferentFunctions","_guessExecutionStatusRelativeTo","TYPES","typeKey","fn","TypeError","keys","indexOf","push","virtualType","checkPath","_default"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/traverse/lib/path/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar _t = require(\"@babel/types\");\n\nvar t = _t;\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst {\n  validate\n} = _t;\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  hasNode() {\n    return this.node != null;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n{\n  NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;\n}\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}