{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"temp\";\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && kind === \"const\";\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path) {\n    let bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {\n      return true;\n    } else if (isClass(node)) {\n      var _node$decorators;\n\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      var _node$decorators2;\n\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n\n      if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {\n        return false;\n      }\n\n      return true;\n    } else if (isProperty(node)) {\n      var _node$decorators3;\n\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n\n      if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {\n        return false;\n      }\n\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getPatternParent() {\n    let scope = this;\n\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while (scope = scope.parent.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {\n      kinds[_key] = arguments[_key];\n    }\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_renamer","require","_index","_binding","_globals","_t","_cache","NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isIdentifier","isImportDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isObjectExpression","isProperty","isPureish","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","isVariableDeclaration","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","isRecordExpression","isTupleExpression","isObjectProperty","isTopicReference","isMetaProperty","isPrivateName","gatherNodeParts","node","parts","type","source","specifiers","length","e","declaration","local","push","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","path","declar","get","isVar","scope","parentScope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","decl","declarations","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","Scope","constructor","block","labels","inited","globals","uids","data","crawling","cached","set","Map","_parent","shouldSkip","listKey","parentPath","isScope","parentBlock","hub","traverse","opts","generateDeclaredUidIdentifier","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","generateUidBasedOnNode","defaultName","join","slice","generateUidIdentifierBasedOnNode","isStatic","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","buildError","TypeError","rename","oldName","newName","_renameFromMap","map","dump","sep","repeat","console","log","violations","toArray","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","registerLabel","label","isLabeledStatement","declare","specifier","buildUndefinedNode","registerConstantViolation","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","addGlobal","hasUid","isPure","constantsOnly","_node$decorators","superClass","decorators","body","method","right","elem","elements","prop","_node$decorators2","computed","_node$decorators3","static","tag","quasi","expressions","setData","val","getData","removeData","init","crawl","create","programParent","_exploded","visit","enter","typeVisitors","ref","getPatternParent","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","unshiftContainer","declarator","len","Error","isFunctionParent","isBlockParent","getAllBindings","getAllBindingsOfKind","kinds","bindingIdentifierEquals","getBindingIdentifier","previousPath","_previousPath","isArrowFunctionExpression","_this$getBinding","getOwnBindingIdentifier","hasOwnBinding","noGlobals","parentHasBinding","includes","contextVariables","_this$parent","moveBindingTo","info","removeOwnBinding","removeBinding","_this$getBinding2","builtin"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/traverse/lib/scope/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && kind === \"const\";\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {\n      return true;\n    } else if (isClass(node)) {\n      var _node$decorators;\n\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      var _node$decorators2;\n\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n\n      if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {\n        return false;\n      }\n\n      return true;\n    } else if (isProperty(node)) {\n      var _node$decorators3;\n\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n\n      if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {\n        return false;\n      }\n\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getPatternParent() {\n    let scope = this;\n\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while (scope = scope.parent.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];"],"mappings":"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"},"metadata":{},"sourceType":"script"}