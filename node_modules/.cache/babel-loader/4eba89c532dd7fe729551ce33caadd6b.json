{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.ensure = ensure;\nexports.get = get;\nexports.getDependencies = getDependencies;\nexports.list = void 0;\nexports.minVersion = minVersion;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helpers = require(\"./helpers\");\n\nconst {\n  assignmentExpression,\n  cloneNode,\n  expressionStatement,\n  file,\n  identifier\n} = _t;\n\nfunction makePath(path) {\n  const parts = [];\n\n  for (; path.parentPath; path = path.parentPath) {\n    parts.push(path.key);\n    if (path.inList) parts.push(path.listKey);\n  }\n\n  return parts.reverse().join(\".\");\n}\n\nlet FileClass = undefined;\n\nfunction getHelperMetadata(file) {\n  const globals = new Set();\n  const localBindingNames = new Set();\n  const dependencies = new Map();\n  let exportName;\n  let exportPath;\n  const exportBindingAssignments = [];\n  const importPaths = [];\n  const importBindingsReferences = [];\n  const dependencyVisitor = {\n    ImportDeclaration(child) {\n      const name = child.node.source.value;\n\n      if (!_helpers.default[name]) {\n        throw child.buildCodeFrameError(`Unknown helper ${name}`);\n      }\n\n      if (child.get(\"specifiers\").length !== 1 || !child.get(\"specifiers.0\").isImportDefaultSpecifier()) {\n        throw child.buildCodeFrameError(\"Helpers can only import a default value\");\n      }\n\n      const bindingIdentifier = child.node.specifiers[0].local;\n      dependencies.set(bindingIdentifier, name);\n      importPaths.push(makePath(child));\n    },\n\n    ExportDefaultDeclaration(child) {\n      const decl = child.get(\"declaration\");\n\n      if (!decl.isFunctionDeclaration() || !decl.node.id) {\n        throw decl.buildCodeFrameError(\"Helpers can only export named function declarations\");\n      }\n\n      exportName = decl.node.id.name;\n      exportPath = makePath(child);\n    },\n\n    ExportAllDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    ExportNamedDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    Statement(child) {\n      if (child.isModuleDeclaration()) return;\n      child.skip();\n    }\n\n  };\n  const referenceVisitor = {\n    Program(path) {\n      const bindings = path.scope.getAllBindings();\n      Object.keys(bindings).forEach(name => {\n        if (name === exportName) return;\n        if (dependencies.has(bindings[name].identifier)) return;\n        localBindingNames.add(name);\n      });\n    },\n\n    ReferencedIdentifier(child) {\n      const name = child.node.name;\n      const binding = child.scope.getBinding(name);\n\n      if (!binding) {\n        globals.add(name);\n      } else if (dependencies.has(binding.identifier)) {\n        importBindingsReferences.push(makePath(child));\n      }\n    },\n\n    AssignmentExpression(child) {\n      const left = child.get(\"left\");\n      if (!(exportName in left.getBindingIdentifiers())) return;\n\n      if (!left.isIdentifier()) {\n        throw left.buildCodeFrameError(\"Only simple assignments to exports are allowed in helpers\");\n      }\n\n      const binding = child.scope.getBinding(exportName);\n\n      if (binding != null && binding.scope.path.isProgram()) {\n        exportBindingAssignments.push(makePath(child));\n      }\n    }\n\n  };\n  (0, _traverse.default)(file.ast, dependencyVisitor, file.scope);\n  (0, _traverse.default)(file.ast, referenceVisitor, file.scope);\n  if (!exportPath) throw new Error(\"Helpers must have a default export.\");\n  exportBindingAssignments.reverse();\n  return {\n    globals: Array.from(globals),\n    localBindingNames: Array.from(localBindingNames),\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  };\n}\n\nfunction permuteHelperAST(file, metadata, id, localBindings, getDependency) {\n  if (localBindings && !id) {\n    throw new Error(\"Unexpected local bindings for module-based helpers.\");\n  }\n\n  if (!id) return;\n  const {\n    localBindingNames,\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  } = metadata;\n  const dependenciesRefs = {};\n  dependencies.forEach((name, id) => {\n    dependenciesRefs[id.name] = typeof getDependency === \"function\" && getDependency(name) || id;\n  });\n  const toRename = {};\n  const bindings = new Set(localBindings || []);\n  localBindingNames.forEach(name => {\n    let newName = name;\n\n    while (bindings.has(newName)) newName = \"_\" + newName;\n\n    if (newName !== name) toRename[name] = newName;\n  });\n\n  if (id.type === \"Identifier\" && exportName !== id.name) {\n    toRename[exportName] = id.name;\n  }\n\n  const {\n    path\n  } = file;\n  const exp = path.get(exportPath);\n  const imps = importPaths.map(p => path.get(p));\n  const impsBindingRefs = importBindingsReferences.map(p => path.get(p));\n  const decl = exp.get(\"declaration\");\n\n  if (id.type === \"Identifier\") {\n    exp.replaceWith(decl);\n  } else if (id.type === \"MemberExpression\") {\n    exportBindingAssignments.forEach(assignPath => {\n      const assign = path.get(assignPath);\n      assign.replaceWith(assignmentExpression(\"=\", id, assign.node));\n    });\n    exp.replaceWith(decl);\n    path.pushContainer(\"body\", expressionStatement(assignmentExpression(\"=\", id, identifier(exportName))));\n  } else {\n    throw new Error(\"Unexpected helper format.\");\n  }\n\n  Object.keys(toRename).forEach(name => {\n    path.scope.rename(name, toRename[name]);\n  });\n\n  for (const path of imps) path.remove();\n\n  for (const path of impsBindingRefs) {\n    const node = cloneNode(dependenciesRefs[path.node.name]);\n    path.replaceWith(node);\n  }\n}\n\nconst helperData = Object.create(null);\n\nfunction loadHelper(name) {\n  if (!helperData[name]) {\n    const helper = _helpers.default[name];\n\n    if (!helper) {\n      throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {\n        code: \"BABEL_HELPER_UNKNOWN\",\n        helper: name\n      });\n    }\n\n    const fn = () => {\n      {\n        if (!FileClass) {\n          const fakeFile = {\n            ast: file(helper.ast()),\n            path: null\n          };\n          (0, _traverse.default)(fakeFile.ast, {\n            Program: path => (fakeFile.path = path).stop()\n          });\n          return fakeFile;\n        }\n      }\n      return new FileClass({\n        filename: `babel-helper://${name}`\n      }, {\n        ast: file(helper.ast()),\n        code: \"[internal Babel helper code]\",\n        inputMap: null\n      });\n    };\n\n    let metadata = null;\n    helperData[name] = {\n      minVersion: helper.minVersion,\n\n      build(getDependency, id, localBindings) {\n        const file = fn();\n        metadata || (metadata = getHelperMetadata(file));\n        permuteHelperAST(file, metadata, id, localBindings, getDependency);\n        return {\n          nodes: file.ast.program.body,\n          globals: metadata.globals\n        };\n      },\n\n      getDependencies() {\n        metadata || (metadata = getHelperMetadata(fn()));\n        return Array.from(metadata.dependencies.values());\n      }\n\n    };\n  }\n\n  return helperData[name];\n}\n\nfunction get(name, getDependency, id, localBindings) {\n  return loadHelper(name).build(getDependency, id, localBindings);\n}\n\nfunction minVersion(name) {\n  return loadHelper(name).minVersion;\n}\n\nfunction getDependencies(name) {\n  return loadHelper(name).getDependencies();\n}\n\nfunction ensure(name, newFileClass) {\n  FileClass || (FileClass = newFileClass);\n  loadHelper(name);\n}\n\nconst list = Object.keys(_helpers.default).map(name => name.replace(/^_/, \"\"));\nexports.list = list;\nvar _default = get;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","ensure","get","getDependencies","list","minVersion","_traverse","require","_t","_helpers","assignmentExpression","cloneNode","expressionStatement","file","identifier","makePath","path","parts","parentPath","push","key","inList","listKey","reverse","join","FileClass","undefined","getHelperMetadata","globals","Set","localBindingNames","dependencies","Map","exportName","exportPath","exportBindingAssignments","importPaths","importBindingsReferences","dependencyVisitor","ImportDeclaration","child","name","node","source","buildCodeFrameError","length","isImportDefaultSpecifier","bindingIdentifier","specifiers","local","set","ExportDefaultDeclaration","decl","isFunctionDeclaration","id","ExportAllDeclaration","ExportNamedDeclaration","Statement","isModuleDeclaration","skip","referenceVisitor","Program","bindings","scope","getAllBindings","keys","forEach","has","add","ReferencedIdentifier","binding","getBinding","AssignmentExpression","left","getBindingIdentifiers","isIdentifier","isProgram","ast","Error","Array","from","permuteHelperAST","metadata","localBindings","getDependency","dependenciesRefs","toRename","newName","type","exp","imps","map","p","impsBindingRefs","replaceWith","assignPath","assign","pushContainer","rename","remove","helperData","create","loadHelper","helper","ReferenceError","code","fn","fakeFile","stop","filename","inputMap","build","nodes","program","body","values","newFileClass","replace","_default"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/helpers/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.ensure = ensure;\nexports.get = get;\nexports.getDependencies = getDependencies;\nexports.list = void 0;\nexports.minVersion = minVersion;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helpers = require(\"./helpers\");\n\nconst {\n  assignmentExpression,\n  cloneNode,\n  expressionStatement,\n  file,\n  identifier\n} = _t;\n\nfunction makePath(path) {\n  const parts = [];\n\n  for (; path.parentPath; path = path.parentPath) {\n    parts.push(path.key);\n    if (path.inList) parts.push(path.listKey);\n  }\n\n  return parts.reverse().join(\".\");\n}\n\nlet FileClass = undefined;\n\nfunction getHelperMetadata(file) {\n  const globals = new Set();\n  const localBindingNames = new Set();\n  const dependencies = new Map();\n  let exportName;\n  let exportPath;\n  const exportBindingAssignments = [];\n  const importPaths = [];\n  const importBindingsReferences = [];\n  const dependencyVisitor = {\n    ImportDeclaration(child) {\n      const name = child.node.source.value;\n\n      if (!_helpers.default[name]) {\n        throw child.buildCodeFrameError(`Unknown helper ${name}`);\n      }\n\n      if (child.get(\"specifiers\").length !== 1 || !child.get(\"specifiers.0\").isImportDefaultSpecifier()) {\n        throw child.buildCodeFrameError(\"Helpers can only import a default value\");\n      }\n\n      const bindingIdentifier = child.node.specifiers[0].local;\n      dependencies.set(bindingIdentifier, name);\n      importPaths.push(makePath(child));\n    },\n\n    ExportDefaultDeclaration(child) {\n      const decl = child.get(\"declaration\");\n\n      if (!decl.isFunctionDeclaration() || !decl.node.id) {\n        throw decl.buildCodeFrameError(\"Helpers can only export named function declarations\");\n      }\n\n      exportName = decl.node.id.name;\n      exportPath = makePath(child);\n    },\n\n    ExportAllDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    ExportNamedDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    Statement(child) {\n      if (child.isModuleDeclaration()) return;\n      child.skip();\n    }\n\n  };\n  const referenceVisitor = {\n    Program(path) {\n      const bindings = path.scope.getAllBindings();\n      Object.keys(bindings).forEach(name => {\n        if (name === exportName) return;\n        if (dependencies.has(bindings[name].identifier)) return;\n        localBindingNames.add(name);\n      });\n    },\n\n    ReferencedIdentifier(child) {\n      const name = child.node.name;\n      const binding = child.scope.getBinding(name);\n\n      if (!binding) {\n        globals.add(name);\n      } else if (dependencies.has(binding.identifier)) {\n        importBindingsReferences.push(makePath(child));\n      }\n    },\n\n    AssignmentExpression(child) {\n      const left = child.get(\"left\");\n      if (!(exportName in left.getBindingIdentifiers())) return;\n\n      if (!left.isIdentifier()) {\n        throw left.buildCodeFrameError(\"Only simple assignments to exports are allowed in helpers\");\n      }\n\n      const binding = child.scope.getBinding(exportName);\n\n      if (binding != null && binding.scope.path.isProgram()) {\n        exportBindingAssignments.push(makePath(child));\n      }\n    }\n\n  };\n  (0, _traverse.default)(file.ast, dependencyVisitor, file.scope);\n  (0, _traverse.default)(file.ast, referenceVisitor, file.scope);\n  if (!exportPath) throw new Error(\"Helpers must have a default export.\");\n  exportBindingAssignments.reverse();\n  return {\n    globals: Array.from(globals),\n    localBindingNames: Array.from(localBindingNames),\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  };\n}\n\nfunction permuteHelperAST(file, metadata, id, localBindings, getDependency) {\n  if (localBindings && !id) {\n    throw new Error(\"Unexpected local bindings for module-based helpers.\");\n  }\n\n  if (!id) return;\n  const {\n    localBindingNames,\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  } = metadata;\n  const dependenciesRefs = {};\n  dependencies.forEach((name, id) => {\n    dependenciesRefs[id.name] = typeof getDependency === \"function\" && getDependency(name) || id;\n  });\n  const toRename = {};\n  const bindings = new Set(localBindings || []);\n  localBindingNames.forEach(name => {\n    let newName = name;\n\n    while (bindings.has(newName)) newName = \"_\" + newName;\n\n    if (newName !== name) toRename[name] = newName;\n  });\n\n  if (id.type === \"Identifier\" && exportName !== id.name) {\n    toRename[exportName] = id.name;\n  }\n\n  const {\n    path\n  } = file;\n  const exp = path.get(exportPath);\n  const imps = importPaths.map(p => path.get(p));\n  const impsBindingRefs = importBindingsReferences.map(p => path.get(p));\n  const decl = exp.get(\"declaration\");\n\n  if (id.type === \"Identifier\") {\n    exp.replaceWith(decl);\n  } else if (id.type === \"MemberExpression\") {\n    exportBindingAssignments.forEach(assignPath => {\n      const assign = path.get(assignPath);\n      assign.replaceWith(assignmentExpression(\"=\", id, assign.node));\n    });\n    exp.replaceWith(decl);\n    path.pushContainer(\"body\", expressionStatement(assignmentExpression(\"=\", id, identifier(exportName))));\n  } else {\n    throw new Error(\"Unexpected helper format.\");\n  }\n\n  Object.keys(toRename).forEach(name => {\n    path.scope.rename(name, toRename[name]);\n  });\n\n  for (const path of imps) path.remove();\n\n  for (const path of impsBindingRefs) {\n    const node = cloneNode(dependenciesRefs[path.node.name]);\n    path.replaceWith(node);\n  }\n}\n\nconst helperData = Object.create(null);\n\nfunction loadHelper(name) {\n  if (!helperData[name]) {\n    const helper = _helpers.default[name];\n\n    if (!helper) {\n      throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {\n        code: \"BABEL_HELPER_UNKNOWN\",\n        helper: name\n      });\n    }\n\n    const fn = () => {\n      {\n        if (!FileClass) {\n          const fakeFile = {\n            ast: file(helper.ast()),\n            path: null\n          };\n          (0, _traverse.default)(fakeFile.ast, {\n            Program: path => (fakeFile.path = path).stop()\n          });\n          return fakeFile;\n        }\n      }\n      return new FileClass({\n        filename: `babel-helper://${name}`\n      }, {\n        ast: file(helper.ast()),\n        code: \"[internal Babel helper code]\",\n        inputMap: null\n      });\n    };\n\n    let metadata = null;\n    helperData[name] = {\n      minVersion: helper.minVersion,\n\n      build(getDependency, id, localBindings) {\n        const file = fn();\n        metadata || (metadata = getHelperMetadata(file));\n        permuteHelperAST(file, metadata, id, localBindings, getDependency);\n        return {\n          nodes: file.ast.program.body,\n          globals: metadata.globals\n        };\n      },\n\n      getDependencies() {\n        metadata || (metadata = getHelperMetadata(fn()));\n        return Array.from(metadata.dependencies.values());\n      }\n\n    };\n  }\n\n  return helperData[name];\n}\n\nfunction get(name, getDependency, id, localBindings) {\n  return loadHelper(name).build(getDependency, id, localBindings);\n}\n\nfunction minVersion(name) {\n  return loadHelper(name).minVersion;\n}\n\nfunction getDependencies(name) {\n  return loadHelper(name).getDependencies();\n}\n\nfunction ensure(name, newFileClass) {\n  FileClass || (FileClass = newFileClass);\n  loadHelper(name);\n}\n\nconst list = Object.keys(_helpers.default).map(name => name.replace(/^_/, \"\"));\nexports.list = list;\nvar _default = get;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}