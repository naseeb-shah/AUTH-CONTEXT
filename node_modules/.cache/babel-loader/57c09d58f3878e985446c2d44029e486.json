{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer\");\n\nvar n = require(\"./node\");\n\nvar _t = require(\"@babel/types\");\n\nvar generatorFunctions = require(\"./generators\");\n\nconst {\n  isProgram,\n  isFile,\n  isEmptyStatement\n} = _t;\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst {\n  needsParens,\n  needsWhitespaceAfter,\n  needsWhitespaceBefore\n} = n;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(47) && str.charCodeAt(0) === 47) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n\n  token(str) {\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n\n    if (str === \"--\" && lastChar === 33 || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline() {\n    let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    const charBeforeNewline = this.endsWithCharAndNewline();\n    if (charBeforeNewline === 10) return;\n\n    if (charBeforeNewline === 123 || charBeforeNewline === 58) {\n      i--;\n    }\n\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str) {\n    let queue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(10) && str.charCodeAt(0) !== 10) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless() {\n    let isLabel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state != null && state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let shouldPrintParens = needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      shouldPrintParens = true;\n    }\n\n    if (shouldPrintParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = isProgram(node) || isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (shouldPrintParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(Math.min(2, lines));\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    const lastCharCode = this.getLastChar();\n\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(47)) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments != null && comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_buffer","require","n","_t","generatorFunctions","isProgram","isFile","isEmptyStatement","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","needsParens","needsWhitespaceAfter","needsWhitespaceBefore","Printer","constructor","format","map","inForStatementInitCounter","_printStack","_indent","_insideAux","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","WeakSet","_endsWithInteger","_endsWithWord","_buf","generate","ast","print","_maybeAddAuxComment","get","indent","compact","concise","dedent","semicolon","force","_append","rightBrace","minified","removeLastSemicolon","token","space","_space","hasContent","lastCp","getLastChar","word","str","endsWith","charCodeAt","number","Number","isInteger","test","length","lastChar","strFirst","newline","i","retainLines","charBeforeNewline","endsWithCharAndNewline","j","_newline","char","removeTrailingNewline","exactSource","loc","cb","_catchUp","source","prop","withSource","queue","_maybeAddParen","_maybeIndent","append","queueIndentation","_getIndent","parenPushNewlineState","cha","chaPost","slice","printed","pos","line","count","getCurrentLine","style","repeat","startTerminatorless","isLabel","endTerminatorless","state","node","parent","oldConcise","_compact","printMethod","type","ReferenceError","JSON","stringify","name","push","oldInAux","shouldPrintParens","retainFunctionParens","extra","parenthesized","_printLeadingComments","call","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","opts","newlineOpts","addNewlines","statement","_printNewline","iterator","separator","printAndIndentOnComments","leadingComments","printBlock","body","_printComments","_getComments","printInnerComments","_node$innerComments","innerComments","printSequence","printList","items","commaSeparator","leading","lines","needs","Math","min","trailingComments","skipNewLines","shouldPrintComment","ignore","has","add","isBlockComment","printNewLines","lastCharCode","val","adjustMultilineComment","_comment$loc","offset","start","column","newlineRegex","RegExp","replace","indentSize","max","getCurrentColumn","comments","inlinePureAnnotation","printAssertions","_node$assertions","assertions","assign","prototype","Noop","_default"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/generator/lib/printer.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer\");\n\nvar n = require(\"./node\");\n\nvar _t = require(\"@babel/types\");\n\nvar generatorFunctions = require(\"./generators\");\n\nconst {\n  isProgram,\n  isFile,\n  isEmptyStatement\n} = _t;\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst {\n  needsParens,\n  needsWhitespaceAfter,\n  needsWhitespaceBefore\n} = n;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(47) && str.charCodeAt(0) === 47) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n\n  token(str) {\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n\n    if (str === \"--\" && lastChar === 33 || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i = 1) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    const charBeforeNewline = this.endsWithCharAndNewline();\n    if (charBeforeNewline === 10) return;\n\n    if (charBeforeNewline === 123 || charBeforeNewline === 58) {\n      i--;\n    }\n\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(10) && str.charCodeAt(0) !== 10) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state != null && state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let shouldPrintParens = needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      shouldPrintParens = true;\n    }\n\n    if (shouldPrintParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = isProgram(node) || isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (shouldPrintParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(Math.min(2, lines));\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    const lastCharCode = this.getLastChar();\n\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(47)) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments != null && comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}