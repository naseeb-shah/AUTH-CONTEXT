{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression() {\n  let {\n    allowInsertArrow = true,\n    specCompliant = false,\n    noNewArrows = !specCompliant\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  fn.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n  }\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, _ref) {\n    let {\n      allSuperCalls\n    } = _ref;\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath) {\n  let noNewArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, _ref2) {\n    let {\n      supers,\n      thisBinding\n    } = _ref2;\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, _ref3) {\n    let {\n      thisPaths\n    } = _ref3;\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, _ref4) {\n    let {\n      thisPaths\n    } = _ref4;\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, _ref5) {\n    let {\n      superCalls\n    } = _ref5;\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, _ref6) {\n    let {\n      superProps\n    } = _ref6;\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, _ref7) {\n    let {\n      argumentsPaths\n    } = _ref7;\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, _ref8) {\n    let {\n      newTargetPaths\n    } = _ref8;\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","arrowFunctionToExpression","arrowFunctionToShadowed","ensureBlock","toComputedKey","unwrapFunctionEnvironment","_t","require","_helperEnvironmentVisitor","_helperFunctionName","_visitors","arrowFunctionExpression","assignmentExpression","binaryExpression","blockStatement","callExpression","conditionalExpression","expressionStatement","identifier","isIdentifier","jsxIdentifier","logicalExpression","LOGICAL_OPERATORS","memberExpression","metaProperty","numericLiteral","objectExpression","restElement","returnStatement","sequenceExpression","spreadElement","stringLiteral","super","_super","thisExpression","toExpression","unaryExpression","key","isMemberExpression","node","property","isProperty","isMethod","ReferenceError","computed","name","body","get","bodyNode","Array","isArray","Error","isBlockStatement","statements","stringPath","listKey","isStatement","push","isFunction","parentPath","setup","isArrowFunctionExpression","isFunctionExpression","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","fnPath","fn","type","checkBinding","scope","generateUidIdentifier","id","init","unshiftContainer","hub","addHelper","replaceWith","default","getSuperCallsVisitor","merge","CallExpression","child","allSuperCalls","isSuper","arrowParent","thisEnvFn","findParent","p","_arrowParent","isProgram","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","kind","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","getScopeInformation","length","traverse","superBinding","getSuperBinding","forEach","superCall","callee","loc","argumentsBinding","getBinding","args","path","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","isAssignment","isAssignmentExpression","left","isCall","isCallExpression","getSuperPropBinding","right","call","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","isLogicalOp","op","includes","operator","assignmentPath","slice","isLogicalAssignment","tmp","generateDeclaredUidIdentifier","object","rightExpression","isUpdateExpression","updateExpr","computedKey","parts","prefix","superClass","assignSuperThisVisitor","supers","has","add","replaceWithMultiple","WeakSet","argsBinding","propName","argsList","fnBody","method","unshift","valueIdent","cacheKey","data","getData","setData","getScopeInformationVisitor","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","Identifier","isReferencedIdentifier","curr","hasOwnBinding","rename","parent","MetaProperty"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/traverse/lib/path/conversion.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  fn.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n  }\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    allSuperCalls\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    supers,\n    thisBinding\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, {\n    thisPaths\n  }) {\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, {\n    thisPaths\n  }) {\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, {\n    superCalls\n  }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, {\n    superProps\n  }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, {\n    argumentsPaths\n  }) {\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, {\n    newTargetPaths\n  }) {\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,yBAAR,GAAoCA,yBAApC;AACAF,OAAO,CAACG,uBAAR,GAAkCA,uBAAlC;AACAH,OAAO,CAACI,WAAR,GAAsBA,WAAtB;AACAJ,OAAO,CAACK,aAAR,GAAwBA,aAAxB;AACAL,OAAO,CAACM,yBAAR,GAAoCA,yBAApC;;AAEA,IAAIC,EAAE,GAAGC,OAAO,CAAC,cAAD,CAAhB;;AAEA,IAAIC,yBAAyB,GAAGD,OAAO,CAAC,mCAAD,CAAvC;;AAEA,IAAIE,mBAAmB,GAAGF,OAAO,CAAC,6BAAD,CAAjC;;AAEA,IAAIG,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAvB;;AAEA,MAAM;EACJI,uBADI;EAEJC,oBAFI;EAGJC,gBAHI;EAIJC,cAJI;EAKJC,cALI;EAMJC,qBANI;EAOJC,mBAPI;EAQJC,UARI;EASJC,YATI;EAUJC,aAVI;EAWJC,iBAXI;EAYJC,iBAZI;EAaJC,gBAbI;EAcJC,YAdI;EAeJC,cAfI;EAgBJC,gBAhBI;EAiBJC,WAjBI;EAkBJC,eAlBI;EAmBJC,kBAnBI;EAoBJC,aApBI;EAqBJC,aArBI;EAsBJC,KAAK,EAAEC,MAtBH;EAuBJC,cAvBI;EAwBJC,YAxBI;EAyBJC;AAzBI,IA0BF9B,EA1BJ;;AA4BA,SAASF,aAAT,GAAyB;EACvB,IAAIiC,GAAJ;;EAEA,IAAI,KAAKC,kBAAL,EAAJ,EAA+B;IAC7BD,GAAG,GAAG,KAAKE,IAAL,CAAUC,QAAhB;EACD,CAFD,MAEO,IAAI,KAAKC,UAAL,MAAqB,KAAKC,QAAL,EAAzB,EAA0C;IAC/CL,GAAG,GAAG,KAAKE,IAAL,CAAUF,GAAhB;EACD,CAFM,MAEA;IACL,MAAM,IAAIM,cAAJ,CAAmB,MAAnB,CAAN;EACD;;EAED,IAAI,CAAC,KAAKJ,IAAL,CAAUK,QAAf,EAAyB;IACvB,IAAIzB,YAAY,CAACkB,GAAD,CAAhB,EAAuBA,GAAG,GAAGN,aAAa,CAACM,GAAG,CAACQ,IAAL,CAAnB;EACxB;;EAED,OAAOR,GAAP;AACD;;AAED,SAASlC,WAAT,GAAuB;EACrB,MAAM2C,IAAI,GAAG,KAAKC,GAAL,CAAS,MAAT,CAAb;EACA,MAAMC,QAAQ,GAAGF,IAAI,CAACP,IAAtB;;EAEA,IAAIU,KAAK,CAACC,OAAN,CAAcJ,IAAd,CAAJ,EAAyB;IACvB,MAAM,IAAIK,KAAJ,CAAU,+CAAV,CAAN;EACD;;EAED,IAAI,CAACH,QAAL,EAAe;IACb,MAAM,IAAIG,KAAJ,CAAU,mCAAV,CAAN;EACD;;EAED,IAAIL,IAAI,CAACM,gBAAL,EAAJ,EAA6B;IAC3B,OAAOJ,QAAP;EACD;;EAED,MAAMK,UAAU,GAAG,EAAnB;EACA,IAAIC,UAAU,GAAG,MAAjB;EACA,IAAIjB,GAAJ;EACA,IAAIkB,OAAJ;;EAEA,IAAIT,IAAI,CAACU,WAAL,EAAJ,EAAwB;IACtBD,OAAO,GAAG,MAAV;IACAlB,GAAG,GAAG,CAAN;IACAgB,UAAU,CAACI,IAAX,CAAgBX,IAAI,CAACP,IAArB;EACD,CAJD,MAIO;IACLe,UAAU,IAAI,SAAd;;IAEA,IAAI,KAAKI,UAAL,EAAJ,EAAuB;MACrBrB,GAAG,GAAG,UAAN;MACAgB,UAAU,CAACI,IAAX,CAAgB7B,eAAe,CAACkB,IAAI,CAACP,IAAN,CAA/B;IACD,CAHD,MAGO;MACLF,GAAG,GAAG,YAAN;MACAgB,UAAU,CAACI,IAAX,CAAgBxC,mBAAmB,CAAC6B,IAAI,CAACP,IAAN,CAAnC;IACD;EACF;;EAED,KAAKA,IAAL,CAAUO,IAAV,GAAiBhC,cAAc,CAACuC,UAAD,CAA/B;EACA,MAAMM,UAAU,GAAG,KAAKZ,GAAL,CAASO,UAAT,CAAnB;EACAR,IAAI,CAACc,KAAL,CAAWD,UAAX,EAAuBJ,OAAO,GAAGI,UAAU,CAACpB,IAAX,CAAgBgB,OAAhB,CAAH,GAA8BI,UAAU,CAACpB,IAAvE,EAA6EgB,OAA7E,EAAsFlB,GAAtF;EACA,OAAO,KAAKE,IAAZ;AACD;;AAED,SAASrC,uBAAT,GAAmC;EACjC,IAAI,CAAC,KAAK2D,yBAAL,EAAL,EAAuC;EACvC,KAAK5D,yBAAL;AACD;;AAED,SAASI,yBAAT,GAAqC;EACnC,IAAI,CAAC,KAAKwD,yBAAL,EAAD,IAAqC,CAAC,KAAKC,oBAAL,EAAtC,IAAqE,CAAC,KAAKC,qBAAL,EAA1E,EAAwG;IACtG,MAAM,KAAKC,mBAAL,CAAyB,gDAAzB,CAAN;EACD;;EAEDC,wBAAwB,CAAC,IAAD,CAAxB;AACD;;AAED,SAAShE,yBAAT,GAIQ;EAAA,IAJ2B;IACjCiE,gBAAgB,GAAG,IADc;IAEjCC,aAAa,GAAG,KAFiB;IAGjCC,WAAW,GAAG,CAACD;EAHkB,CAI3B,uEAAJ,EAAI;;EACN,IAAI,CAAC,KAAKN,yBAAL,EAAL,EAAuC;IACrC,MAAM,KAAKG,mBAAL,CAAyB,6DAAzB,CAAN;EACD;;EAED,MAAM;IACJK,WADI;IAEJC,MAAM,EAAEC;EAFJ,IAGFN,wBAAwB,CAAC,IAAD,EAAOG,WAAP,EAAoBF,gBAApB,CAH5B;EAIAK,EAAE,CAACpE,WAAH;EACAoE,EAAE,CAAChC,IAAH,CAAQiC,IAAR,GAAe,oBAAf;;EAEA,IAAI,CAACJ,WAAL,EAAkB;IAChB,MAAMK,YAAY,GAAGJ,WAAW,GAAG,IAAH,GAAUE,EAAE,CAACG,KAAH,CAASC,qBAAT,CAA+B,cAA/B,CAA1C;;IAEA,IAAIF,YAAJ,EAAkB;MAChBF,EAAE,CAACZ,UAAH,CAAce,KAAd,CAAoBjB,IAApB,CAAyB;QACvBmB,EAAE,EAAEH,YADmB;QAEvBI,IAAI,EAAEnD,gBAAgB,CAAC,EAAD;MAFC,CAAzB;IAID;;IAED6C,EAAE,CAACxB,GAAH,CAAO,MAAP,EAAe+B,gBAAf,CAAgC,MAAhC,EAAwC7D,mBAAmB,CAACF,cAAc,CAAC,KAAKgE,GAAL,CAASC,SAAT,CAAmB,eAAnB,CAAD,EAAsC,CAAC9C,cAAc,EAAf,EAAmBuC,YAAY,GAAGvD,UAAU,CAACuD,YAAY,CAAC5B,IAAd,CAAb,GAAmC3B,UAAU,CAACmD,WAAD,CAA5E,CAAtC,CAAf,CAA3D;IACAE,EAAE,CAACU,WAAH,CAAelE,cAAc,CAACQ,gBAAgB,CAAC,CAAC,GAAGd,mBAAmB,CAACyE,OAAxB,EAAiC,IAAjC,EAAuC,IAAvC,KAAgDX,EAAE,CAAChC,IAApD,EAA0DrB,UAAU,CAAC,MAAD,CAApE,CAAjB,EAAgG,CAACuD,YAAY,GAAGvD,UAAU,CAACuD,YAAY,CAAC5B,IAAd,CAAb,GAAmCX,cAAc,EAA9D,CAAhG,CAA7B;EACD;AACF;;AAED,MAAMiD,oBAAoB,GAAG,CAAC,GAAGzE,SAAS,CAAC0E,KAAd,EAAqB,CAAC;EACjDC,cAAc,CAACC,KAAD,QAEX;IAAA,IAFmB;MACpBC;IADoB,CAEnB;IACD,IAAI,CAACD,KAAK,CAACvC,GAAN,CAAU,QAAV,EAAoByC,OAApB,EAAL,EAAoC;IACpCD,aAAa,CAAC9B,IAAd,CAAmB6B,KAAnB;EACD;;AANgD,CAAD,EAQ/C9E,yBAAyB,CAAC0E,OARqB,CAArB,CAA7B;;AAUA,SAASjB,wBAAT,CAAkCK,MAAlC,EAAuF;EAAA,IAA7CF,WAA6C,uEAA/B,IAA+B;EAAA,IAAzBF,gBAAyB,uEAAN,IAAM;EACrF,IAAIuB,WAAJ;EACA,IAAIC,SAAS,GAAGpB,MAAM,CAACqB,UAAP,CAAkBC,CAAC,IAAI;IACrC,IAAIA,CAAC,CAAC/B,yBAAF,EAAJ,EAAmC;MACjC,IAAIgC,YAAJ;;MAEA,CAACA,YAAY,GAAGJ,WAAhB,KAAgC,IAAhC,GAAuCI,YAAvC,GAAsDJ,WAAW,GAAGG,CAApE;MACA,OAAO,KAAP;IACD;;IAED,OAAOA,CAAC,CAAClC,UAAF,MAAkBkC,CAAC,CAACE,SAAF,EAAlB,IAAmCF,CAAC,CAACG,eAAF,CAAkB;MAC1DC,MAAM,EAAE;IADkD,CAAlB,CAAnC,IAEDJ,CAAC,CAACK,sBAAF,CAAyB;MAC7BD,MAAM,EAAE;IADqB,CAAzB,CAFN;EAKD,CAbe,CAAhB;EAcA,MAAME,aAAa,GAAGR,SAAS,CAACS,aAAV,CAAwB;IAC5CC,IAAI,EAAE;EADsC,CAAxB,CAAtB;;EAIA,IAAIV,SAAS,CAACK,eAAV,MAA+BL,SAAS,CAACO,sBAAV,EAAnC,EAAuE;IACrE,IAAIR,WAAJ,EAAiB;MACfC,SAAS,GAAGD,WAAZ;IACD,CAFD,MAEO,IAAIvB,gBAAJ,EAAsB;MAC3BI,MAAM,CAACW,WAAP,CAAmBlE,cAAc,CAACJ,uBAAuB,CAAC,EAAD,EAAKwB,YAAY,CAACmC,MAAM,CAAC/B,IAAR,CAAjB,CAAxB,EAAyD,EAAzD,CAAjC;MACAmD,SAAS,GAAGpB,MAAM,CAACvB,GAAP,CAAW,QAAX,CAAZ;MACAuB,MAAM,GAAGoB,SAAS,CAAC3C,GAAV,CAAc,MAAd,CAAT;IACD,CAJM,MAIA;MACL,MAAMuB,MAAM,CAACN,mBAAP,CAA2B,iDAA3B,CAAN;IACD;EACF;;EAED,MAAM;IACJqC,SADI;IAEJC,cAFI;IAGJC,cAHI;IAIJC,UAJI;IAKJC;EALI,IAMFC,mBAAmB,CAACpC,MAAD,CANvB;;EAQA,IAAI4B,aAAa,IAAIO,UAAU,CAACE,MAAX,GAAoB,CAAzC,EAA4C;IAC1C,IAAI,CAACzC,gBAAL,EAAuB;MACrB,MAAMuC,UAAU,CAAC,CAAD,CAAV,CAAczC,mBAAd,CAAkC,gDAAlC,CAAN;IACD;;IAED,MAAMuB,aAAa,GAAG,EAAtB;IACAG,SAAS,CAACkB,QAAV,CAAmBzB,oBAAnB,EAAyC;MACvCI;IADuC,CAAzC;IAGA,MAAMsB,YAAY,GAAGC,eAAe,CAACpB,SAAD,CAApC;IACAH,aAAa,CAACwB,OAAd,CAAsBC,SAAS,IAAI;MACjC,MAAMC,MAAM,GAAG/F,UAAU,CAAC2F,YAAD,CAAzB;MACAI,MAAM,CAACC,GAAP,GAAaF,SAAS,CAACzE,IAAV,CAAe0E,MAAf,CAAsBC,GAAnC;MACAF,SAAS,CAACjE,GAAV,CAAc,QAAd,EAAwBkC,WAAxB,CAAoCgC,MAApC;IACD,CAJD;EAKD;;EAED,IAAIX,cAAc,CAACK,MAAf,GAAwB,CAA5B,EAA+B;IAC7B,MAAMQ,gBAAgB,GAAGC,UAAU,CAAC1B,SAAD,EAAY,WAAZ,EAAyB,MAAM;MAChE,MAAM2B,IAAI,GAAG,MAAMnG,UAAU,CAAC,WAAD,CAA7B;;MAEA,IAAIwE,SAAS,CAAChB,KAAV,CAAgB4C,IAAhB,CAAqBxB,SAArB,EAAJ,EAAsC;QACpC,OAAO9E,qBAAqB,CAACH,gBAAgB,CAAC,KAAD,EAAQuB,eAAe,CAAC,QAAD,EAAWiF,IAAI,EAAf,CAAvB,EAA2CtF,aAAa,CAAC,WAAD,CAAxD,CAAjB,EAAyF2D,SAAS,CAAChB,KAAV,CAAgB6C,kBAAhB,EAAzF,EAA+HF,IAAI,EAAnI,CAA5B;MACD,CAFD,MAEO;QACL,OAAOA,IAAI,EAAX;MACD;IACF,CARkC,CAAnC;IASAf,cAAc,CAACS,OAAf,CAAuBS,cAAc,IAAI;MACvC,MAAMC,OAAO,GAAGvG,UAAU,CAACiG,gBAAD,CAA1B;MACAM,OAAO,CAACP,GAAR,GAAcM,cAAc,CAACjF,IAAf,CAAoB2E,GAAlC;MACAM,cAAc,CAACvC,WAAf,CAA2BwC,OAA3B;IACD,CAJD;EAKD;;EAED,IAAIlB,cAAc,CAACI,MAAf,GAAwB,CAA5B,EAA+B;IAC7B,MAAMe,gBAAgB,GAAGN,UAAU,CAAC1B,SAAD,EAAY,WAAZ,EAAyB,MAAMlE,YAAY,CAACN,UAAU,CAAC,KAAD,CAAX,EAAoBA,UAAU,CAAC,QAAD,CAA9B,CAA3C,CAAnC;IACAqF,cAAc,CAACQ,OAAf,CAAuBY,WAAW,IAAI;MACpC,MAAMC,SAAS,GAAG1G,UAAU,CAACwG,gBAAD,CAA5B;MACAE,SAAS,CAACV,GAAV,GAAgBS,WAAW,CAACpF,IAAZ,CAAiB2E,GAAjC;MACAS,WAAW,CAAC1C,WAAZ,CAAwB2C,SAAxB;IACD,CAJD;EAKD;;EAED,IAAIpB,UAAU,CAACG,MAAX,GAAoB,CAAxB,EAA2B;IACzB,IAAI,CAACzC,gBAAL,EAAuB;MACrB,MAAMsC,UAAU,CAAC,CAAD,CAAV,CAAcxC,mBAAd,CAAkC,0CAAlC,CAAN;IACD;;IAED,MAAM6D,cAAc,GAAGrB,UAAU,CAACsB,MAAX,CAAkB,CAACC,GAAD,EAAMC,SAAN,KAAoBD,GAAG,CAACE,MAAJ,CAAWC,wBAAwB,CAACF,SAAD,CAAnC,CAAtC,EAAuF,EAAvF,CAAvB;IACAH,cAAc,CAACd,OAAf,CAAuBiB,SAAS,IAAI;MAClC,MAAM3F,GAAG,GAAG2F,SAAS,CAACzF,IAAV,CAAeK,QAAf,GAA0B,EAA1B,GAA+BoF,SAAS,CAACjF,GAAV,CAAc,UAAd,EAA0BR,IAA1B,CAA+BM,IAA1E;MACA,MAAMsF,YAAY,GAAGH,SAAS,CAACrE,UAAV,CAAqByE,sBAArB,CAA4C;QAC/DC,IAAI,EAAEL,SAAS,CAACzF;MAD+C,CAA5C,CAArB;MAGA,MAAM+F,MAAM,GAAGN,SAAS,CAACrE,UAAV,CAAqB4E,gBAArB,CAAsC;QACnDtB,MAAM,EAAEe,SAAS,CAACzF;MADiC,CAAtC,CAAf;MAGA,MAAMsE,YAAY,GAAG2B,mBAAmB,CAAC9C,SAAD,EAAYyC,YAAZ,EAA0B9F,GAA1B,CAAxC;MACA,MAAMgF,IAAI,GAAG,EAAb;;MAEA,IAAIW,SAAS,CAACzF,IAAV,CAAeK,QAAnB,EAA6B;QAC3ByE,IAAI,CAAC5D,IAAL,CAAUuE,SAAS,CAACjF,GAAV,CAAc,UAAd,EAA0BR,IAApC;MACD;;MAED,IAAI4F,YAAJ,EAAkB;QAChB,MAAMnI,KAAK,GAAGgI,SAAS,CAACrE,UAAV,CAAqBpB,IAArB,CAA0BkG,KAAxC;QACApB,IAAI,CAAC5D,IAAL,CAAUzD,KAAV;MACD;;MAED,MAAM0I,IAAI,GAAG3H,cAAc,CAACG,UAAU,CAAC2F,YAAD,CAAX,EAA2BQ,IAA3B,CAA3B;;MAEA,IAAIiB,MAAJ,EAAY;QACVN,SAAS,CAACrE,UAAV,CAAqBmB,gBAArB,CAAsC,WAAtC,EAAmD5C,cAAc,EAAjE;QACA8F,SAAS,CAAC/C,WAAV,CAAsB1D,gBAAgB,CAACmH,IAAD,EAAOxH,UAAU,CAAC,MAAD,CAAjB,CAAtC;QACAmF,SAAS,CAAC5C,IAAV,CAAeuE,SAAS,CAACrE,UAAV,CAAqBZ,GAArB,CAAyB,aAAzB,CAAf;MACD,CAJD,MAIO,IAAIoF,YAAJ,EAAkB;QACvBH,SAAS,CAACrE,UAAV,CAAqBsB,WAArB,CAAiCyD,IAAjC;MACD,CAFM,MAEA;QACLV,SAAS,CAAC/C,WAAV,CAAsByD,IAAtB;MACD;IACF,CA/BD;EAgCD;;EAED,IAAIrE,WAAJ;;EAEA,IAAIgC,SAAS,CAACM,MAAV,GAAmB,CAAnB,IAAwB,CAACvC,WAA7B,EAA0C;IACxCC,WAAW,GAAGsE,cAAc,CAACjD,SAAD,EAAYQ,aAAZ,CAA5B;;IAEA,IAAI9B,WAAW,IAAI8B,aAAa,IAAI0C,aAAa,CAAClD,SAAD,CAAjD,EAA8D;MAC5DW,SAAS,CAACU,OAAV,CAAkB8B,SAAS,IAAI;QAC7B,MAAMC,OAAO,GAAGD,SAAS,CAACE,KAAV,KAAoB3H,aAAa,CAACiD,WAAD,CAAjC,GAAiDnD,UAAU,CAACmD,WAAD,CAA3E;QACAyE,OAAO,CAAC5B,GAAR,GAAc2B,SAAS,CAACtG,IAAV,CAAe2E,GAA7B;QACA2B,SAAS,CAAC5D,WAAV,CAAsB6D,OAAtB;MACD,CAJD;MAKA,IAAI,CAAC1E,WAAL,EAAkBC,WAAW,GAAG,IAAd;IACnB;EACF;;EAED,OAAO;IACLA,WADK;IAELC;EAFK,CAAP;AAID;;AAED,SAAS0E,WAAT,CAAqBC,EAArB,EAAyB;EACvB,OAAO3H,iBAAiB,CAAC4H,QAAlB,CAA2BD,EAA3B,CAAP;AACD;;AAED,SAASf,wBAAT,CAAkCF,SAAlC,EAA6C;EAC3C,IAAIA,SAAS,CAACrE,UAAV,CAAqByE,sBAArB,MAAiDJ,SAAS,CAACrE,UAAV,CAAqBpB,IAArB,CAA0B4G,QAA1B,KAAuC,GAA5F,EAAiG;IAC/F,MAAMC,cAAc,GAAGpB,SAAS,CAACrE,UAAjC;IACA,MAAMsF,EAAE,GAAGG,cAAc,CAAC7G,IAAf,CAAoB4G,QAApB,CAA6BE,KAA7B,CAAmC,CAAnC,EAAsC,CAAC,CAAvC,CAAX;IACA,MAAMrJ,KAAK,GAAGoJ,cAAc,CAAC7G,IAAf,CAAoBkG,KAAlC;IACA,MAAMa,mBAAmB,GAAGN,WAAW,CAACC,EAAD,CAAvC;;IAEA,IAAIjB,SAAS,CAACzF,IAAV,CAAeK,QAAnB,EAA6B;MAC3B,MAAM2G,GAAG,GAAGvB,SAAS,CAACtD,KAAV,CAAgB8E,6BAAhB,CAA8C,KAA9C,CAAZ;MACA,MAAMC,MAAM,GAAGzB,SAAS,CAACzF,IAAV,CAAekH,MAA9B;MACA,MAAMjH,QAAQ,GAAGwF,SAAS,CAACzF,IAAV,CAAeC,QAAhC;MACA4G,cAAc,CAACrG,GAAf,CAAmB,MAAnB,EAA2BkC,WAA3B,CAAuC1D,gBAAgB,CAACkI,MAAD,EAAS7I,oBAAoB,CAAC,GAAD,EAAM2I,GAAN,EAAW/G,QAAX,CAA7B,EAAmD,IAAnD,CAAvD;MACA4G,cAAc,CAACrG,GAAf,CAAmB,OAAnB,EAA4BkC,WAA5B,CAAwCyE,eAAe,CAACJ,mBAAmB,GAAG,GAAH,GAASL,EAA7B,EAAiC1H,gBAAgB,CAACkI,MAAD,EAASvI,UAAU,CAACqI,GAAG,CAAC1G,IAAL,CAAnB,EAA+B,IAA/B,CAAjD,EAAuF7C,KAAvF,CAAvD;IACD,CAND,MAMO;MACL,MAAMyJ,MAAM,GAAGzB,SAAS,CAACzF,IAAV,CAAekH,MAA9B;MACA,MAAMjH,QAAQ,GAAGwF,SAAS,CAACzF,IAAV,CAAeC,QAAhC;MACA4G,cAAc,CAACrG,GAAf,CAAmB,MAAnB,EAA2BkC,WAA3B,CAAuC1D,gBAAgB,CAACkI,MAAD,EAASjH,QAAT,CAAvD;MACA4G,cAAc,CAACrG,GAAf,CAAmB,OAAnB,EAA4BkC,WAA5B,CAAwCyE,eAAe,CAACJ,mBAAmB,GAAG,GAAH,GAASL,EAA7B,EAAiC1H,gBAAgB,CAACkI,MAAD,EAASvI,UAAU,CAACsB,QAAQ,CAACK,IAAV,CAAnB,CAAjD,EAAsF7C,KAAtF,CAAvD;IACD;;IAED,IAAIsJ,mBAAJ,EAAyB;MACvBF,cAAc,CAACnE,WAAf,CAA2B5D,iBAAiB,CAAC4H,EAAD,EAAKG,cAAc,CAAC7G,IAAf,CAAoB8F,IAAzB,EAA+Be,cAAc,CAAC7G,IAAf,CAAoBkG,KAAnD,CAA5C;IACD,CAFD,MAEO;MACLW,cAAc,CAAC7G,IAAf,CAAoB4G,QAApB,GAA+B,GAA/B;IACD;;IAED,OAAO,CAACC,cAAc,CAACrG,GAAf,CAAmB,MAAnB,CAAD,EAA6BqG,cAAc,CAACrG,GAAf,CAAmB,OAAnB,EAA4BA,GAA5B,CAAgC,MAAhC,CAA7B,CAAP;EACD,CA1BD,MA0BO,IAAIiF,SAAS,CAACrE,UAAV,CAAqBgG,kBAArB,EAAJ,EAA+C;IACpD,MAAMC,UAAU,GAAG5B,SAAS,CAACrE,UAA7B;IACA,MAAM4F,GAAG,GAAGvB,SAAS,CAACtD,KAAV,CAAgB8E,6BAAhB,CAA8C,KAA9C,CAAZ;IACA,MAAMK,WAAW,GAAG7B,SAAS,CAACzF,IAAV,CAAeK,QAAf,GAA0BoF,SAAS,CAACtD,KAAV,CAAgB8E,6BAAhB,CAA8C,MAA9C,CAA1B,GAAkF,IAAtG;IACA,MAAMM,KAAK,GAAG,CAAClJ,oBAAoB,CAAC,GAAD,EAAM2I,GAAN,EAAWhI,gBAAgB,CAACyG,SAAS,CAACzF,IAAV,CAAekH,MAAhB,EAAwBI,WAAW,GAAGjJ,oBAAoB,CAAC,GAAD,EAAMiJ,WAAN,EAAmB7B,SAAS,CAACzF,IAAV,CAAeC,QAAlC,CAAvB,GAAqEwF,SAAS,CAACzF,IAAV,CAAeC,QAAvH,EAAiIwF,SAAS,CAACzF,IAAV,CAAeK,QAAhJ,CAA3B,CAArB,EAA4MhC,oBAAoB,CAAC,GAAD,EAAMW,gBAAgB,CAACyG,SAAS,CAACzF,IAAV,CAAekH,MAAhB,EAAwBI,WAAW,GAAG3I,UAAU,CAAC2I,WAAW,CAAChH,IAAb,CAAb,GAAkCmF,SAAS,CAACzF,IAAV,CAAeC,QAApF,EAA8FwF,SAAS,CAACzF,IAAV,CAAeK,QAA7G,CAAtB,EAA8I/B,gBAAgB,CAACmH,SAAS,CAACrE,UAAV,CAAqBpB,IAArB,CAA0B4G,QAA1B,CAAmC,CAAnC,CAAD,EAAwCjI,UAAU,CAACqI,GAAG,CAAC1G,IAAL,CAAlD,EAA8DpB,cAAc,CAAC,CAAD,CAA5E,CAA9J,CAAhO,CAAd;;IAEA,IAAI,CAACuG,SAAS,CAACrE,UAAV,CAAqBpB,IAArB,CAA0BwH,MAA/B,EAAuC;MACrCD,KAAK,CAACrG,IAAN,CAAWvC,UAAU,CAACqI,GAAG,CAAC1G,IAAL,CAArB;IACD;;IAED+G,UAAU,CAAC3E,WAAX,CAAuBpD,kBAAkB,CAACiI,KAAD,CAAzC;IACA,MAAMzB,IAAI,GAAGuB,UAAU,CAAC7G,GAAX,CAAe,qBAAf,CAAb;IACA,MAAM0F,KAAK,GAAGmB,UAAU,CAAC7G,GAAX,CAAe,oBAAf,CAAd;IACA,OAAO,CAACsF,IAAD,EAAOI,KAAP,CAAP;EACD;;EAED,OAAO,CAACT,SAAD,CAAP;;EAEA,SAAS0B,eAAT,CAAyBT,EAAzB,EAA6BZ,IAA7B,EAAmCI,KAAnC,EAA0C;IACxC,IAAIQ,EAAE,KAAK,GAAX,EAAgB;MACd,OAAOrI,oBAAoB,CAAC,GAAD,EAAMyH,IAAN,EAAYI,KAAZ,CAA3B;IACD,CAFD,MAEO;MACL,OAAO5H,gBAAgB,CAACoI,EAAD,EAAKZ,IAAL,EAAWI,KAAX,CAAvB;IACD;EACF;AACF;;AAED,SAASG,aAAT,CAAuBlD,SAAvB,EAAkC;EAChC,OAAOA,SAAS,CAACS,aAAV,MAA6B,CAAC,CAACT,SAAS,CAAC/B,UAAV,CAAqBA,UAArB,CAAgCpB,IAAhC,CAAqCyH,UAA3E;AACD;;AAED,MAAMC,sBAAsB,GAAG,CAAC,GAAGvJ,SAAS,CAAC0E,KAAd,EAAqB,CAAC;EACnDC,cAAc,CAACC,KAAD,SAGX;IAAA,IAHmB;MACpB4E,MADoB;MAEpB7F;IAFoB,CAGnB;IACD,IAAI,CAACiB,KAAK,CAACvC,GAAN,CAAU,QAAV,EAAoByC,OAApB,EAAL,EAAoC;IACpC,IAAI0E,MAAM,CAACC,GAAP,CAAW7E,KAAK,CAAC/C,IAAjB,CAAJ,EAA4B;IAC5B2H,MAAM,CAACE,GAAP,CAAW9E,KAAK,CAAC/C,IAAjB;IACA+C,KAAK,CAAC+E,mBAAN,CAA0B,CAAC/E,KAAK,CAAC/C,IAAP,EAAa3B,oBAAoB,CAAC,GAAD,EAAMM,UAAU,CAACmD,WAAD,CAAhB,EAA+BnD,UAAU,CAAC,MAAD,CAAzC,CAAjC,CAA1B;EACD;;AATkD,CAAD,EAWjDV,yBAAyB,CAAC0E,OAXuB,CAArB,CAA/B;;AAaA,SAASyD,cAAT,CAAwBjD,SAAxB,EAAmCQ,aAAnC,EAAkD;EAChD,OAAOkB,UAAU,CAAC1B,SAAD,EAAY,MAAZ,EAAoBrB,WAAW,IAAI;IAClD,IAAI,CAAC6B,aAAD,IAAkB,CAAC0C,aAAa,CAAClD,SAAD,CAApC,EAAiD,OAAOxD,cAAc,EAArB;IACjDwD,SAAS,CAACkB,QAAV,CAAmBqD,sBAAnB,EAA2C;MACzCC,MAAM,EAAE,IAAII,OAAJ,EADiC;MAEzCjG;IAFyC,CAA3C;EAID,CANgB,CAAjB;AAOD;;AAED,SAASyC,eAAT,CAAyBpB,SAAzB,EAAoC;EAClC,OAAO0B,UAAU,CAAC1B,SAAD,EAAY,WAAZ,EAAyB,MAAM;IAC9C,MAAM6E,WAAW,GAAG7E,SAAS,CAAChB,KAAV,CAAgBC,qBAAhB,CAAsC,MAAtC,CAApB;IACA,OAAOhE,uBAAuB,CAAC,CAACgB,WAAW,CAAC4I,WAAD,CAAZ,CAAD,EAA6BxJ,cAAc,CAACkB,MAAM,EAAP,EAAW,CAACH,aAAa,CAACZ,UAAU,CAACqJ,WAAW,CAAC1H,IAAb,CAAX,CAAd,CAAX,CAA3C,CAA9B;EACD,CAHgB,CAAjB;AAID;;AAED,SAAS2F,mBAAT,CAA6B9C,SAA7B,EAAwCyC,YAAxC,EAAsDqC,QAAtD,EAAgE;EAC9D,MAAMvB,EAAE,GAAGd,YAAY,GAAG,KAAH,GAAW,KAAlC;EACA,OAAOf,UAAU,CAAC1B,SAAD,EAAa,aAAYuD,EAAG,IAAGuB,QAAQ,IAAI,EAAG,EAA9C,EAAiD,MAAM;IACtE,MAAMC,QAAQ,GAAG,EAAjB;IACA,IAAIC,MAAJ;;IAEA,IAAIF,QAAJ,EAAc;MACZE,MAAM,GAAGnJ,gBAAgB,CAACU,MAAM,EAAP,EAAWf,UAAU,CAACsJ,QAAD,CAArB,CAAzB;IACD,CAFD,MAEO;MACL,MAAMG,MAAM,GAAGjF,SAAS,CAAChB,KAAV,CAAgBC,qBAAhB,CAAsC,MAAtC,CAAf;MACA8F,QAAQ,CAACG,OAAT,CAAiBD,MAAjB;MACAD,MAAM,GAAGnJ,gBAAgB,CAACU,MAAM,EAAP,EAAWf,UAAU,CAACyJ,MAAM,CAAC9H,IAAR,CAArB,EAAoC,IAApC,CAAzB;IACD;;IAED,IAAIsF,YAAJ,EAAkB;MAChB,MAAM0C,UAAU,GAAGnF,SAAS,CAAChB,KAAV,CAAgBC,qBAAhB,CAAsC,OAAtC,CAAnB;MACA8F,QAAQ,CAAChH,IAAT,CAAcoH,UAAd;MACAH,MAAM,GAAG9J,oBAAoB,CAAC,GAAD,EAAM8J,MAAN,EAAcxJ,UAAU,CAAC2J,UAAU,CAAChI,IAAZ,CAAxB,CAA7B;IACD;;IAED,OAAOlC,uBAAuB,CAAC8J,QAAD,EAAWC,MAAX,CAA9B;EACD,CAnBgB,CAAjB;AAoBD;;AAED,SAAStD,UAAT,CAAoB1B,SAApB,EAA+BrD,GAA/B,EAAoCwC,IAApC,EAA0C;EACxC,MAAMiG,QAAQ,GAAG,aAAazI,GAA9B;EACA,IAAI0I,IAAI,GAAGrF,SAAS,CAACsF,OAAV,CAAkBF,QAAlB,CAAX;;EAEA,IAAI,CAACC,IAAL,EAAW;IACT,MAAMnG,EAAE,GAAGc,SAAS,CAAChB,KAAV,CAAgBC,qBAAhB,CAAsCtC,GAAtC,CAAX;IACA0I,IAAI,GAAGnG,EAAE,CAAC/B,IAAV;IACA6C,SAAS,CAACuF,OAAV,CAAkBH,QAAlB,EAA4BC,IAA5B;IACArF,SAAS,CAAChB,KAAV,CAAgBjB,IAAhB,CAAqB;MACnBmB,EAAE,EAAEA,EADe;MAEnBC,IAAI,EAAEA,IAAI,CAACkG,IAAD;IAFS,CAArB;EAID;;EAED,OAAOA,IAAP;AACD;;AAED,MAAMG,0BAA0B,GAAG,CAAC,GAAGxK,SAAS,CAAC0E,KAAd,EAAqB,CAAC;EACvD+F,cAAc,CAAC7F,KAAD,SAEX;IAAA,IAFmB;MACpBe;IADoB,CAEnB;IACDA,SAAS,CAAC5C,IAAV,CAAe6B,KAAf;EACD,CALsD;;EAOvD8F,aAAa,CAAC9F,KAAD,SAEV;IAAA,IAFkB;MACnBe;IADmB,CAElB;IACD,IAAIf,KAAK,CAAC/C,IAAN,CAAWM,IAAX,KAAoB,MAAxB,EAAgC;;IAEhC,IAAI,CAACyC,KAAK,CAAC3B,UAAN,CAAiB0H,qBAAjB,CAAuC;MAC1C5B,MAAM,EAAEnE,KAAK,CAAC/C;IAD4B,CAAvC,CAAD,IAEE,CAAC+C,KAAK,CAAC3B,UAAN,CAAiB2H,mBAAjB,CAAqC;MAC1CzI,IAAI,EAAEyC,KAAK,CAAC/C;IAD8B,CAArC,CAFP,EAII;MACF;IACD;;IAED8D,SAAS,CAAC5C,IAAV,CAAe6B,KAAf;EACD,CArBsD;;EAuBvDD,cAAc,CAACC,KAAD,SAEX;IAAA,IAFmB;MACpBmB;IADoB,CAEnB;IACD,IAAInB,KAAK,CAACvC,GAAN,CAAU,QAAV,EAAoByC,OAApB,EAAJ,EAAmCiB,UAAU,CAAChD,IAAX,CAAgB6B,KAAhB;EACpC,CA3BsD;;EA6BvDiG,gBAAgB,CAACjG,KAAD,SAEb;IAAA,IAFqB;MACtBkB;IADsB,CAErB;IACD,IAAIlB,KAAK,CAACvC,GAAN,CAAU,QAAV,EAAoByC,OAApB,EAAJ,EAAmCgB,UAAU,CAAC/C,IAAX,CAAgB6B,KAAhB;EACpC,CAjCsD;;EAmCvDkG,UAAU,CAAClG,KAAD,SAEP;IAAA,IAFe;MAChBgB;IADgB,CAEf;IACD,IAAI,CAAChB,KAAK,CAACmG,sBAAN,CAA6B;MAChC5I,IAAI,EAAE;IAD0B,CAA7B,CAAL,EAEI;IACJ,IAAI6I,IAAI,GAAGpG,KAAK,CAACZ,KAAjB;;IAEA,GAAG;MACD,IAAIgH,IAAI,CAACC,aAAL,CAAmB,WAAnB,CAAJ,EAAqC;QACnCD,IAAI,CAACE,MAAL,CAAY,WAAZ;QACA;MACD;;MAED,IAAIF,IAAI,CAACpE,IAAL,CAAU5D,UAAV,MAA0B,CAACgI,IAAI,CAACpE,IAAL,CAAUzD,yBAAV,EAA/B,EAAsE;QACpE;MACD;IACF,CATD,QASS6H,IAAI,GAAGA,IAAI,CAACG,MATrB;;IAWAvF,cAAc,CAAC7C,IAAf,CAAoB6B,KAApB;EACD,CAvDsD;;EAyDvDwG,YAAY,CAACxG,KAAD,SAET;IAAA,IAFiB;MAClBiB;IADkB,CAEjB;IACD,IAAI,CAACjB,KAAK,CAACvC,GAAN,CAAU,MAAV,EAAkB5B,YAAlB,CAA+B;MAClC0B,IAAI,EAAE;IAD4B,CAA/B,CAAL,EAEI;IACJ,IAAI,CAACyC,KAAK,CAACvC,GAAN,CAAU,UAAV,EAAsB5B,YAAtB,CAAmC;MACtC0B,IAAI,EAAE;IADgC,CAAnC,CAAL,EAEI;IACJ0D,cAAc,CAAC9C,IAAf,CAAoB6B,KAApB;EACD;;AAnEsD,CAAD,EAqErD9E,yBAAyB,CAAC0E,OArE2B,CAArB,CAAnC;;AAuEA,SAASwB,mBAAT,CAA6BpC,MAA7B,EAAqC;EACnC,MAAM+B,SAAS,GAAG,EAAlB;EACA,MAAMC,cAAc,GAAG,EAAvB;EACA,MAAMC,cAAc,GAAG,EAAvB;EACA,MAAMC,UAAU,GAAG,EAAnB;EACA,MAAMC,UAAU,GAAG,EAAnB;EACAnC,MAAM,CAACsC,QAAP,CAAgBsE,0BAAhB,EAA4C;IAC1C7E,SAD0C;IAE1CC,cAF0C;IAG1CC,cAH0C;IAI1CC,UAJ0C;IAK1CC;EAL0C,CAA5C;EAOA,OAAO;IACLJ,SADK;IAELC,cAFK;IAGLC,cAHK;IAILC,UAJK;IAKLC;EALK,CAAP;AAOD"},"metadata":{},"sourceType":"script"}