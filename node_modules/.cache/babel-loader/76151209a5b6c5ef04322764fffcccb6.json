{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nvar context = require(\"../index\");\n\nvar _plugin = require(\"./plugin\");\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nvar _deepArray = require(\"./helpers/deep-array\");\n\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"./caching\");\n\nvar _options = require(\"./validation/options\");\n\nvar _plugins = require(\"./validation/plugins\");\n\nvar _configApi = require(\"./helpers/config-api\");\n\nvar _partial = require(\"./partial\");\n\nvar Context = require(\"./cache-contexts\");\n\nvar _default = _gensync()(function* loadFullConfig(inputOpts) {\n  var _opts$assumptions;\n\n  const result = yield* (0, _partial.default)(inputOpts);\n\n  if (!result) {\n    return null;\n  }\n\n  const {\n    options,\n    context,\n    fileHandling\n  } = result;\n\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n\n  const optionDefaults = {};\n  const {\n    plugins,\n    presets\n  } = options;\n\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n\n  const presetContext = Object.assign({}, context, {\n    targets: options.targets\n  });\n\n  const toDescriptor = item => {\n    const desc = (0, _item.getItemDescriptor)(item);\n\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n\n    return desc;\n  };\n\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass = [[]];\n  const passes = [];\n  const externalDependencies = [];\n  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n    const presets = [];\n\n    for (let i = 0; i < rawPresets.length; i++) {\n      const descriptor = rawPresets[i];\n\n      if (descriptor.options !== false) {\n        try {\n          var preset = yield* loadPresetDescriptor(descriptor, presetContext);\n        } catch (e) {\n          if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", e);\n          }\n\n          throw e;\n        }\n\n        externalDependencies.push(preset.externalDependencies);\n\n        if (descriptor.ownPass) {\n          presets.push({\n            preset: preset.chain,\n            pass: []\n          });\n        } else {\n          presets.unshift({\n            preset: preset.chain,\n            pass: pluginDescriptorsPass\n          });\n        }\n      }\n    }\n\n    if (presets.length > 0) {\n      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));\n\n      for (const {\n        preset,\n        pass\n      } of presets) {\n        if (!preset) return true;\n        pass.push(...preset.plugins);\n        const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n        if (ignored) return true;\n        preset.options.forEach(opts => {\n          (0, _util.mergeOptions)(optionDefaults, opts);\n        });\n      }\n    }\n  })(presetsDescriptors, pluginDescriptorsByPass[0]);\n  if (ignored) return null;\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  const pluginContext = Object.assign({}, presetContext, {\n    assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}\n  });\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n\n    for (const descs of pluginDescriptorsByPass) {\n      const pass = [];\n      passes.push(pass);\n\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor = descs[i];\n\n        if (descriptor.options !== false) {\n          try {\n            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", e);\n            }\n\n            throw e;\n          }\n\n          pass.push(plugin);\n          externalDependencies.push(plugin.externalDependencies);\n        }\n      }\n    }\n  })();\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\n\nexports.default = _default;\n\nfunction enhanceError(context, fn) {\n  return function* (arg1, arg2) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        e.message = `[BABEL] ${context.filename || \"unknown\"}: ${e.message}`;\n      }\n\n      throw e;\n    }\n  };\n}\n\nconst makeDescriptorLoader = apiFactory => (0, _caching.makeWeakCache)(function* (_ref, cache) {\n  let {\n    value,\n    options,\n    dirname,\n    alias\n  } = _ref;\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  const externalDependencies = [];\n  let item = value;\n\n  if (typeof value === \"function\") {\n    const factory = (0, _async.maybeAsync)(value, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);\n    const api = Object.assign({}, context, apiFactory(cache, externalDependencies));\n\n    try {\n      item = yield* factory(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += ` (While processing: ${JSON.stringify(alias)})`;\n      }\n\n      throw e;\n    }\n  }\n\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n\n  if ((0, _async.isThenable)(item)) {\n    yield* [];\n    throw new Error(`You appear to be using a promise as a plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version. ` + `As an alternative, you can prefix the promise with \"await\". ` + `(While processing: ${JSON.stringify(alias)})`);\n  }\n\n  if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === \"forever\")) {\n    let error = `A plugin/preset has external untracked dependencies ` + `(${externalDependencies[0]}), but the cache `;\n\n    if (!cache.configured()) {\n      error += `has not been configured to be invalidated when the external dependencies change. `;\n    } else {\n      error += ` has been configured to never be invalidated. `;\n    }\n\n    error += `Plugins/presets should configure their cache to be invalidated when the external ` + `dependencies change, for example using \\`api.cache.invalidate(() => ` + `statSync(filepath).mtimeMs)\\` or \\`api.cache.never()\\`\\n` + `(While processing: ${JSON.stringify(alias)})`;\n    throw new Error(error);\n  }\n\n  return {\n    value: item,\n    options,\n    dirname,\n    alias,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\n\nconst pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);\nconst presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);\n\nfunction* loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n\n    return descriptor.value;\n  }\n\n  return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context), context);\n}\n\nconst instantiatePlugin = (0, _caching.makeWeakCache)(function* (_ref2, cache) {\n  let {\n    value,\n    options,\n    dirname,\n    alias,\n    externalDependencies\n  } = _ref2;\n  const pluginObj = (0, _plugins.validatePluginObject)(value);\n  const plugin = Object.assign({}, pluginObj);\n\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname\n    };\n    const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n\n    if (inherits.externalDependencies.length > 0) {\n      if (externalDependencies.length === 0) {\n        externalDependencies = inherits.externalDependencies;\n      } else {\n        externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);\n      }\n    }\n  }\n\n  return new _plugin.default(plugin, options, alias, externalDependencies);\n});\n\nconst validateIfOptionNeedsFilename = (options, descriptor) => {\n  if (options.test || options.include || options.exclude) {\n    const formattedPresetName = descriptor.name ? `\"${descriptor.name}\"` : \"/* your preset */\";\n    throw new Error([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\\`\\`\\``, `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\\`\\`\\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join(\"\\n\"));\n  }\n};\n\nconst validatePreset = (preset, context, descriptor) => {\n  if (!context.filename) {\n    const {\n      options\n    } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));\n    }\n  }\n};\n\nfunction* loadPresetDescriptor(descriptor, context) {\n  const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context));\n  validatePreset(preset, context, descriptor);\n  return {\n    chain: yield* (0, _configChain.buildPresetChain)(preset, context),\n    externalDependencies: preset.externalDependencies\n  };\n}\n\nconst instantiatePreset = (0, _caching.makeWeakCacheSync)(_ref3 => {\n  let {\n    value,\n    dirname,\n    alias,\n    externalDependencies\n  } = _ref3;\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname,\n    externalDependencies\n  };\n});\n\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_gensync","data","require","_async","_util","context","_plugin","_item","_configChain","_deepArray","_traverse","_caching","_options","_plugins","_configApi","_partial","Context","_default","loadFullConfig","inputOpts","_opts$assumptions","result","options","fileHandling","optionDefaults","plugins","presets","Error","presetContext","assign","targets","toDescriptor","item","desc","getItemDescriptor","presetsDescriptors","map","initialPluginsDescriptors","pluginDescriptorsByPass","passes","externalDependencies","ignored","enhanceError","recursePresetDescriptors","rawPresets","pluginDescriptorsPass","i","length","descriptor","preset","loadPresetDescriptor","e","code","checkNoUnwrappedItemOptionPairs","push","ownPass","chain","pass","unshift","splice","o","filter","p","forEach","opts","mergeOptions","pluginContext","assumptions","loadPluginDescriptors","descs","plugin","loadPluginDescriptor","slice","passPerPreset","finalize","fn","arg1","arg2","test","message","filename","makeDescriptorLoader","apiFactory","makeWeakCache","cache","dirname","alias","factory","maybeAsync","api","JSON","stringify","isThenable","configured","mode","error","pluginDescriptorLoader","makePluginAPI","presetDescriptorLoader","makePresetAPI","instantiatePlugin","pluginObj","validatePluginObject","visitor","explode","inherits","inheritsDescriptor","name","undefined","forwardAsync","run","invalidate","pre","post","manipulateOptions","visitors","merge","validateIfOptionNeedsFilename","include","exclude","formattedPresetName","join","validatePreset","overrides","overrideOptions","instantiatePreset","buildPresetChain","makeWeakCacheSync","validate","a","b","fns","Boolean","args","apply"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/core/lib/config/full.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nvar context = require(\"../index\");\n\nvar _plugin = require(\"./plugin\");\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nvar _deepArray = require(\"./helpers/deep-array\");\n\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"./caching\");\n\nvar _options = require(\"./validation/options\");\n\nvar _plugins = require(\"./validation/plugins\");\n\nvar _configApi = require(\"./helpers/config-api\");\n\nvar _partial = require(\"./partial\");\n\nvar Context = require(\"./cache-contexts\");\n\nvar _default = _gensync()(function* loadFullConfig(inputOpts) {\n  var _opts$assumptions;\n\n  const result = yield* (0, _partial.default)(inputOpts);\n\n  if (!result) {\n    return null;\n  }\n\n  const {\n    options,\n    context,\n    fileHandling\n  } = result;\n\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n\n  const optionDefaults = {};\n  const {\n    plugins,\n    presets\n  } = options;\n\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n\n  const presetContext = Object.assign({}, context, {\n    targets: options.targets\n  });\n\n  const toDescriptor = item => {\n    const desc = (0, _item.getItemDescriptor)(item);\n\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n\n    return desc;\n  };\n\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass = [[]];\n  const passes = [];\n  const externalDependencies = [];\n  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n    const presets = [];\n\n    for (let i = 0; i < rawPresets.length; i++) {\n      const descriptor = rawPresets[i];\n\n      if (descriptor.options !== false) {\n        try {\n          var preset = yield* loadPresetDescriptor(descriptor, presetContext);\n        } catch (e) {\n          if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", e);\n          }\n\n          throw e;\n        }\n\n        externalDependencies.push(preset.externalDependencies);\n\n        if (descriptor.ownPass) {\n          presets.push({\n            preset: preset.chain,\n            pass: []\n          });\n        } else {\n          presets.unshift({\n            preset: preset.chain,\n            pass: pluginDescriptorsPass\n          });\n        }\n      }\n    }\n\n    if (presets.length > 0) {\n      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));\n\n      for (const {\n        preset,\n        pass\n      } of presets) {\n        if (!preset) return true;\n        pass.push(...preset.plugins);\n        const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n        if (ignored) return true;\n        preset.options.forEach(opts => {\n          (0, _util.mergeOptions)(optionDefaults, opts);\n        });\n      }\n    }\n  })(presetsDescriptors, pluginDescriptorsByPass[0]);\n  if (ignored) return null;\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  const pluginContext = Object.assign({}, presetContext, {\n    assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}\n  });\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n\n    for (const descs of pluginDescriptorsByPass) {\n      const pass = [];\n      passes.push(pass);\n\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor = descs[i];\n\n        if (descriptor.options !== false) {\n          try {\n            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", e);\n            }\n\n            throw e;\n          }\n\n          pass.push(plugin);\n          externalDependencies.push(plugin.externalDependencies);\n        }\n      }\n    }\n  })();\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\n\nexports.default = _default;\n\nfunction enhanceError(context, fn) {\n  return function* (arg1, arg2) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        e.message = `[BABEL] ${context.filename || \"unknown\"}: ${e.message}`;\n      }\n\n      throw e;\n    }\n  };\n}\n\nconst makeDescriptorLoader = apiFactory => (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) {\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  const externalDependencies = [];\n  let item = value;\n\n  if (typeof value === \"function\") {\n    const factory = (0, _async.maybeAsync)(value, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);\n    const api = Object.assign({}, context, apiFactory(cache, externalDependencies));\n\n    try {\n      item = yield* factory(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += ` (While processing: ${JSON.stringify(alias)})`;\n      }\n\n      throw e;\n    }\n  }\n\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n\n  if ((0, _async.isThenable)(item)) {\n    yield* [];\n    throw new Error(`You appear to be using a promise as a plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version. ` + `As an alternative, you can prefix the promise with \"await\". ` + `(While processing: ${JSON.stringify(alias)})`);\n  }\n\n  if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === \"forever\")) {\n    let error = `A plugin/preset has external untracked dependencies ` + `(${externalDependencies[0]}), but the cache `;\n\n    if (!cache.configured()) {\n      error += `has not been configured to be invalidated when the external dependencies change. `;\n    } else {\n      error += ` has been configured to never be invalidated. `;\n    }\n\n    error += `Plugins/presets should configure their cache to be invalidated when the external ` + `dependencies change, for example using \\`api.cache.invalidate(() => ` + `statSync(filepath).mtimeMs)\\` or \\`api.cache.never()\\`\\n` + `(While processing: ${JSON.stringify(alias)})`;\n    throw new Error(error);\n  }\n\n  return {\n    value: item,\n    options,\n    dirname,\n    alias,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\n\nconst pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);\nconst presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);\n\nfunction* loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n\n    return descriptor.value;\n  }\n\n  return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context), context);\n}\n\nconst instantiatePlugin = (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias,\n  externalDependencies\n}, cache) {\n  const pluginObj = (0, _plugins.validatePluginObject)(value);\n  const plugin = Object.assign({}, pluginObj);\n\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname\n    };\n    const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n\n    if (inherits.externalDependencies.length > 0) {\n      if (externalDependencies.length === 0) {\n        externalDependencies = inherits.externalDependencies;\n      } else {\n        externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);\n      }\n    }\n  }\n\n  return new _plugin.default(plugin, options, alias, externalDependencies);\n});\n\nconst validateIfOptionNeedsFilename = (options, descriptor) => {\n  if (options.test || options.include || options.exclude) {\n    const formattedPresetName = descriptor.name ? `\"${descriptor.name}\"` : \"/* your preset */\";\n    throw new Error([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\\`\\`\\``, `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\\`\\`\\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join(\"\\n\"));\n  }\n};\n\nconst validatePreset = (preset, context, descriptor) => {\n  if (!context.filename) {\n    const {\n      options\n    } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));\n    }\n  }\n};\n\nfunction* loadPresetDescriptor(descriptor, context) {\n  const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context));\n  validatePreset(preset, context, descriptor);\n  return {\n    chain: yield* (0, _configChain.buildPresetChain)(preset, context),\n    externalDependencies: preset.externalDependencies\n  };\n}\n\nconst instantiatePreset = (0, _caching.makeWeakCacheSync)(({\n  value,\n  dirname,\n  alias,\n  externalDependencies\n}) => {\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname,\n    externalDependencies\n  };\n});\n\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function (...args) {\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}