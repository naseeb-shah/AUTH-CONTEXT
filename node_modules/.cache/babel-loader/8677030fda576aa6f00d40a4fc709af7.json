{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ArrayExpression","AssignmentExpression","BinaryExpression","BooleanLiteral","CallExpression","ConditionalExpression","ClassDeclaration","ClassExpression","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","Func","enumerable","get","_infererReference","default","LogicalExpression","NewExpression","NullLiteral","NumericLiteral","ObjectExpression","ParenthesizedExpression","RegExpLiteral","RestElement","SequenceExpression","StringLiteral","TaggedTemplateExpression","TemplateLiteral","TypeCastExpression","UnaryExpression","UpdateExpression","VariableDeclarator","_t","require","BOOLEAN_BINARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","NUMBER_BINARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","anyTypeAnnotation","arrayTypeAnnotation","booleanTypeAnnotation","buildMatchMemberExpression","createFlowUnionType","createTSUnionType","createUnionTypeAnnotation","genericTypeAnnotation","identifier","isTSTypeAnnotation","nullLiteralTypeAnnotation","numberTypeAnnotation","stringTypeAnnotation","tupleTypeAnnotation","unionTypeAnnotation","voidTypeAnnotation","_type","id","isIdentifier","init","type","getTypeAnnotation","isCallExpression","name","scope","hasBinding","node","typeAnnotation","validParent","callee","operator","indexOf","right","left","isBaseType","argumentTypes","pop","isArrayFrom","isObjectKeys","isObjectValues","isObjectEntries","resolveCall","resolve","isFunction","is","returnType"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/traverse/lib/path/inference/inferers.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}