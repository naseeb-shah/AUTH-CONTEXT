{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertSimpleType = assertSimpleType;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nconst synchronize = gen => {\n  return _gensync()(gen).sync;\n};\n\nfunction* genTrue() {\n  return true;\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  const callCacheSync = new CallCache();\n  const callCacheAsync = new CallCache();\n  const futureCache = new CallCache();\n  return function* cachedFunction(arg, data) {\n    const asyncContext = yield* (0, _async.isAsync)();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n    const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);\n    if (cached.valid) return cached.value;\n    const cache = new CacheConfigurator(data);\n    const handlerResult = handler(arg, cache);\n    let finishLock;\n    let value;\n\n    if ((0, _util.isIterableIterator)(handlerResult)) {\n      const gen = handlerResult;\n      value = yield* (0, _async.onFirstPause)(gen, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\nfunction* getCachedValue(cache, arg, data) {\n  const cachedValue = cache.get(arg);\n\n  if (cachedValue) {\n    for (const {\n      value,\n      valid\n    } of cachedValue) {\n      if (yield* valid(data)) return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  const cached = yield* getCachedValue(callCache, arg, data);\n\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n\n    if (cached.valid) {\n      const value = yield* (0, _async.waitFor)(cached.value.promise);\n      return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  const finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  let cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n    const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);\n\n    if ((0, _async.isThenable)(key)) {\n      return key.then(key => {\n        this._pairs.push([key, fn]);\n\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return function* (data) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nclass Lock {\n  constructor() {\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value) {\n    this.released = true;\n\n    this._resolve(value);\n  }\n\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","assertSimpleType","makeStrongCache","makeStrongCacheSync","makeWeakCache","makeWeakCacheSync","_gensync","data","require","_async","_util","synchronize","gen","sync","genTrue","handler","makeCachedFunction","WeakMap","Map","CallCache","callCacheSync","callCacheAsync","futureCache","cachedFunction","arg","asyncContext","isAsync","callCache","cached","getCachedValueOrWait","valid","cache","CacheConfigurator","handlerResult","finishLock","isIterableIterator","onFirstPause","setupAsyncLocks","updateFunctionCache","delete","release","getCachedValue","cachedValue","get","waitFor","promise","config","Lock","configured","forever","deactivate","mode","set","validator","push","constructor","_active","_never","_forever","_invalidate","_configured","_pairs","_data","simple","makeSimpleConfigurator","Error","never","using","key","fn","maybeAsync","isThenable","then","invalidate","pairs","cacheFn","val","cb","released","_resolve","Promise","resolve"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/core/lib/config/caching.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertSimpleType = assertSimpleType;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nconst synchronize = gen => {\n  return _gensync()(gen).sync;\n};\n\nfunction* genTrue() {\n  return true;\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  const callCacheSync = new CallCache();\n  const callCacheAsync = new CallCache();\n  const futureCache = new CallCache();\n  return function* cachedFunction(arg, data) {\n    const asyncContext = yield* (0, _async.isAsync)();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n    const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);\n    if (cached.valid) return cached.value;\n    const cache = new CacheConfigurator(data);\n    const handlerResult = handler(arg, cache);\n    let finishLock;\n    let value;\n\n    if ((0, _util.isIterableIterator)(handlerResult)) {\n      const gen = handlerResult;\n      value = yield* (0, _async.onFirstPause)(gen, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\nfunction* getCachedValue(cache, arg, data) {\n  const cachedValue = cache.get(arg);\n\n  if (cachedValue) {\n    for (const {\n      value,\n      valid\n    } of cachedValue) {\n      if (yield* valid(data)) return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  const cached = yield* getCachedValue(callCache, arg, data);\n\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n\n    if (cached.valid) {\n      const value = yield* (0, _async.waitFor)(cached.value.promise);\n      return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  const finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  let cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n    const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);\n\n    if ((0, _async.isThenable)(key)) {\n      return key.then(key => {\n        this._pairs.push([key, fn]);\n\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return function* (data) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nclass Lock {\n  constructor() {\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value) {\n    this.released = true;\n\n    this._resolve(value);\n  }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}