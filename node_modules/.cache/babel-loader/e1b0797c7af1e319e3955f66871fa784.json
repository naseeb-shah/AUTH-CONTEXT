{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\n\nvar _t = require(\"@babel/types\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nconst {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse\n} = _t;\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const isLegacyRef = {\n    value: undefined\n  };\n  traverse(ast, placeholderVisitorHandler, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  });\n  return Object.assign({\n    ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\n\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n\n  let name;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (isNewExpression(parent) && key === \"arguments\" || isCallExpression(parent) && key === \"arguments\" || isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const {\n    placeholders,\n    placeholderNames\n  } = state.isLegacyRef.value ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\n\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins\n  });\n\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","parseAndBuildMetadata","_t","require","_parser","_codeFrame","isCallExpression","isExpressionStatement","isFunction","isIdentifier","isJSXIdentifier","isNewExpression","isPlaceholder","isStatement","isStringLiteral","removePropertiesDeep","traverse","PATTERN","formatter","code","opts","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","ast","parseWithCodeFrame","parser","validate","syntactic","placeholders","placeholderNames","Set","legacy","isLegacyRef","undefined","placeholderVisitorHandler","assign","node","ancestors","state","_state$placeholderWhi","name","Error","test","has","slice","parent","key","length","type","expectedNode","push","resolve","resolveAncestors","isDuplicate","add","i","index","parserOpts","plugins","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","parse","err","loc","message","codeFrameColumns","start"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/template/lib/parse.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\n\nvar _t = require(\"@babel/types\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nconst {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse\n} = _t;\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const isLegacyRef = {\n    value: undefined\n  };\n  traverse(ast, placeholderVisitorHandler, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  });\n  return Object.assign({\n    ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\n\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n\n  let name;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (isNewExpression(parent) && key === \"arguments\" || isCallExpression(parent) && key === \"arguments\" || isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const {\n    placeholders,\n    placeholderNames\n  } = state.isLegacyRef.value ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\n\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins\n  });\n\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}