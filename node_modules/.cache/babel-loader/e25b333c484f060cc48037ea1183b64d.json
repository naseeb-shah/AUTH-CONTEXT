{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nconst last = arr => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path) {\n  return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));\n}\n\nfunction isAlmostConstantAssignment(node, scope) {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  const blockScope = scope.getBlockParent();\n  return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (isHiddenInSequenceExpression(this)) {\n        nodes.unshift(node);\n      } else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        nodes.push(node);\n      } else {\n        if (parentPath.isMethod({\n          computed: true,\n          key: node\n        })) {\n          scope = scope.parent;\n        }\n\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist() {\n  let scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_containerInsert","_containerInsertAfter","_containerInsertBefore","_verifyNodeList","hoist","insertAfter","insertBefore","pushContainer","unshiftContainer","updateSiblingKeys","_cache","require","_hoister","_index","_t","arrowFunctionExpression","assertExpression","assignmentExpression","blockStatement","callExpression","cloneNode","expressionStatement","isAssignmentExpression","isCallExpression","isExpression","isIdentifier","isSequenceExpression","isSuper","thisExpression","nodes_","_assertUnremoved","nodes","parentPath","isExpressionStatement","isLabeledStatement","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","key","node","push","replaceExpressionWithStatements","Array","isArray","container","isStatementOrBlock","shouldInsertCurrentNode","expression","replaceWith","Error","from","length","paths","splice","i","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","last","arr","isHiddenInSequenceExpression","parent","expressions","isAlmostConstantAssignment","scope","left","blockScope","getBlockParent","hasOwnBinding","name","getOwnBinding","constantViolations","get","map","isPattern","unshift","callee","isPure","isMethod","computed","temp","generateDeclaredUidIdentifier","fromIndex","incrementBy","msg","type","default","listKey","setContext","verifiedNodes","replaceWithMultiple","hoister","run"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/traverse/lib/path/modification.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nconst last = arr => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path) {\n  return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));\n}\n\nfunction isAlmostConstantAssignment(node, scope) {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  const blockScope = scope.getBlockParent();\n  return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (isHiddenInSequenceExpression(this)) {\n        nodes.unshift(node);\n      } else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        nodes.push(node);\n      } else {\n        if (parentPath.isMethod({\n          computed: true,\n          key: node\n        })) {\n          scope = scope.parent;\n        }\n\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}