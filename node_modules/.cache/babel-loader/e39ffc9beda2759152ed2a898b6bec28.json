{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state) {\n  let raw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","evaluate","evaluateTruthy","VALID_CALLEES","INVALID_METHODS","res","confident","deopt","path","state","deoptPath","evaluateCached","node","seen","has","existing","get","resolved","item","set","val","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","undefined","Infinity","NaN","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","key","computed","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","Math","pow","context","func","indexOf","global","args","map","apply","raw","str","i","cooked","expr","String","Map"],"sources":["C:/Users/arrow/Desktop/Software Topics/React.js/ui/node_modules/@babel/traverse/lib/path/evaluation.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}